<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-planar-projection-mapping.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Проецирование текстуры как плоскости">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ru.jpg">

<meta property="og:title" content="WebGL2 Планарное и перспективное проекционное отображение">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ru.jpg">
<meta property="og:description" content="Проецирование текстуры как плоскости">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-planar-projection-mapping.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Планарное и перспективное проекционное отображение">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-planar-projection-mapping.html">
<meta name="twitter:description" content="Проецирование текстуры как плоскости">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-planar-projection-mapping.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-planar-projection-mapping_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-planar-projection-mapping.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-planar-projection-mapping.html",
      "inLanguage":"ru",
      "name":"WebGL2 Планарное и перспективное проекционное отображение",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-planar-projection-mapping.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Планарное и перспективное проекционное отображение</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-planar-projection-mapping.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-planar-projection-mapping.html" >English</a>
    <option value="/webgl/lessons/de/webgl-planar-projection-mapping.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-planar-projection-mapping.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-planar-projection-mapping.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-planar-projection-mapping.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-planar-projection-mapping.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html" >简体中文</a>
</select>


    <a href="#toc">Содержание</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Планарное и перспективное проекционное отображение</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>В этой статье предполагается, что вы уже прочитали статью
<a href="webgl-less-code-more-fun.html">меньше кода — больше удовольствия</a>,
так как здесь используется упомянутая там библиотека для
упрощения примера. Если вы не понимаете, что такое буферы, вершинные массивы, атрибуты или
что значит функция <code class="notranslate" translate="no">twgl.setUniforms</code>, как устанавливать uniforms и т.д.,
то вам стоит вернуться и <a href="webgl-fundamentals.html">прочитать основы</a>.</p>
<p>Также предполагается, что вы прочитали <a href="webgl-3d-perspective.html">статьи о перспективе</a>,
<a href="webgl-3d-camera.html">статью о камерах</a>, <a href="webgl-3d-textures.html">статью о текстурах</a>
и <a href="webgl-visualizing-the-camera.html">статью о визуализации камеры</a>,
поэтому если вы их не читали, начните с них.</p>
<p>Проекционное отображение — это процесс «проецирования» изображения, как если бы вы
направили кинопроектор на экран и спроецировали на него фильм.
Кинопроектор проецирует перспективную плоскость. Чем дальше экран от проектора,
тем больше изображение. Если наклонить экран, чтобы он был не перпендикулярен проектору,
получится трапеция или произвольный четырёхугольник.</p>
<div class="webgl_center"><img src="../resources/perspective-projection.svg" style="width: 400px"></div>
<p>Конечно, проекционное отображение не обязательно должно быть плоским. Существуют
цилиндрические, сферические и другие виды проекционного отображения.</p>
<p>Сначала рассмотрим планарное проекционное отображение. В этом случае
можно представить, что проектор такого же размера, как и экран,
поэтому изображение не увеличивается с удалением экрана от проектора, а остаётся одного размера.</p>
<div class="webgl_center"><img src="../resources/orthographic-projection.svg" style="width: 400px"></div>
<p>Для начала создадим простую сцену с плоскостью и сферой.
Мы наложим на обе объекты простую 8x8 текстуру в виде шахматной доски.</p>
<p>Шейдеры похожи на те, что были в <a href="webgl-3d-textures.html">статье о текстурах</a>,
только матрицы разделены, чтобы не умножать их в JavaScript.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `#version 300 es
in vec4 a_position;
in vec2 a_texcoord;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform mat4 u_textureMatrix;

out vec2 v_texcoord;
out vec4 v_projectedTexcoord;

void main() {
  vec4 worldPosition = u_world * a_position;

  gl_Position = u_projection * u_view * worldPosition;

  // Передаём текстурные координаты во фрагментный шейдер.
  v_texcoord = a_texcoord;

  v_projectedTexcoord = u_textureMatrix * worldPosition;
}
`;
</code></pre>
<p>Также я добавил uniform <code class="notranslate" translate="no">u_colorMult</code>, чтобы умножать цвет текстуры.
Используя монохромную текстуру, мы можем менять её цвет таким образом.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
precision highp float;

// Передано из вершинного шейдера.
in vec2 v_texcoord;
in vec4 v_projectedTexcoord;

uniform vec4 u_colorMult;
uniform sampler2D u_texture;
uniform sampler2D u_projectedTexture;

out vec4 outColor;

void main() {
  // делим на w, чтобы получить правильное значение. См. статью о перспективе
  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;

  bool inRange = 
      projectedTexcoord.x &gt;= 0.0 &amp;&amp;
      projectedTexcoord.x &lt;= 1.0 &amp;&amp;
      projectedTexcoord.y &gt;= 0.0 &amp;&amp;
      projectedTexcoord.y &lt;= 1.0;

  vec4 projectedTexColor = texture(u_projectedTexture, projectedTexcoord.xy);
  vec4 texColor = texture(u_texture, v_texcoord) * u_colorMult;

  float projectedAmount = inRange ? 1.0 : 0.0;
  outColor = mix(texColor, projectedTexColor, projectedAmount);
}
`;
</code></pre>
<p>Вот код для настройки программы, буферов сферы и плоскости:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// настройка GLSL программы
// компиляция шейдеров, линковка программы, поиск локаций
const textureProgramInfo = twgl.createProgramInfo(gl, [vs, fs]);

const sphereBufferInfo = primitives.createSphereBufferInfo(
    gl,
    1,  // радиус
    12, // делений по кругу
    6,  // делений по высоте
);
const sphereVAO = twgl.createVAOFromBufferInfo(
    gl, textureProgramInfo, sphereBufferInfo);
const planeBufferInfo = primitives.createPlaneBufferInfo(
    gl,
    20,  // ширина
    20,  // высота
    1,   // делений по ширине
    1,   // делений по высоте
);
const planeVAO = twgl.createVAOFromBufferInfo(
    gl, textureProgramInfo, planeBufferInfo);
</code></pre>
<p>и код для создания 8x8 текстуры-шахматки
(см. <a href="webgl-data-textures.html">статью о data-текстурах</a>):</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// создаём 8x8 текстуру-шахматку
const checkerboardTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, checkerboardTexture);
gl.texImage2D(
    gl.TEXTURE_2D,
    0,                // mip уровень
    gl.LUMINANCE,     // внутренний формат
    8,                // ширина
    8,                // высота
    0,                // граница
    gl.LUMINANCE,     // формат
    gl.UNSIGNED_BYTE, // тип
    new Uint8Array([  // данные
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
      0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
      0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
    ]));
gl.generateMipmap(gl.TEXTURE_2D);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
</code></pre>
<p>Для рендера создадим функцию, которая принимает матрицу проекции
и матрицу камеры, вычисляет view-матрицу из матрицы камеры,
а затем рисует сферу и плоскость:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Uniforms для каждого объекта.
const planeUniforms = {
  u_colorMult: [0.5, 0.5, 1, 1],  // светло-голубой
  u_texture: checkerboardTexture,
  u_world: m4.translation(0, 0, 0),
};
const sphereUniforms = {
  u_colorMult: [1, 0.5, 0.5, 1],  // розовый
  u_texture: checkerboardTexture,
  u_world: m4.translation(2, 3, 4),
};

function drawScene(projectionMatrix, cameraMatrix) {
  // Получаем view-матрицу из матрицы камеры.
  const viewMatrix = m4.inverse(cameraMatrix);

  gl.useProgram(textureProgramInfo.program);

  // Устанавливаем uniforms, общие для сферы и плоскости
  twgl.setUniforms(textureProgramInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
  });

  // ------ Рисуем сферу --------

  // Настраиваем все нужные атрибуты.
  gl.bindVertexArray(sphereVAO);

  // Устанавливаем uniforms, уникальные для сферы
  twgl.setUniforms(textureProgramInfo, sphereUniforms);

  // вызывает gl.drawArrays или gl.drawElements
  twgl.drawBufferInfo(gl, sphereBufferInfo);

  // ------ Рисуем плоскость --------

  // Настраиваем все нужные атрибуты.
  gl.bindVertexArray(planeVAO);

  // Устанавливаем uniforms, уникальные для плоскости
  twgl.setUniforms(textureProgramInfo, planeUniforms);

  // вызывает gl.drawArrays или gl.drawElements
  twgl.drawBufferInfo(gl, planeBufferInfo);
}
</code></pre>
<p>Эту функцию можно вызывать из функции <code class="notranslate" translate="no">render</code> примерно так:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
};
const fieldOfViewRadians = degToRad(60);

function render() {
  twgl.resizeCanvasToDisplaySize(gl.canvas);

  // Говорим WebGL, как конвертировать из clip space в пиксели
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  gl.enable(gl.CULL_FACE);
  gl.enable(gl.DEPTH_TEST);

  // Очищаем canvas И буфер глубины.
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Вычисляем матрицу проекции
  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const projectionMatrix =
      m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

  // Вычисляем матрицу камеры, используя look at.
  const cameraPosition = [settings.cameraX, settings.cameraY, 7];
  const target = [0, 0, 0];
  const up = [0, 1, 0];
  const cameraMatrix = m4.lookAt(cameraPosition, target, up);

  drawScene(projectionMatrix, cameraMatrix);
}
render();
</code></pre>
<p>Теперь у нас есть простая сцена с плоскостью и сферой.
Я добавил несколько слайдеров, чтобы вы могли изменить позицию камеры
и лучше понять сцену.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection-setup.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection-setup.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Теперь давайте планарно спроецируем текстуру на сферу и плоскость.</p>
<p>Первое, что нужно сделать — <a href="webgl-3d-textures.html">загрузить текстуру</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function loadImageTexture(url) {
  // Создаём текстуру.
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  // Заполняем текстуру 1x1 синим пикселем.
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                new Uint8Array([0, 0, 255, 255]));
  // Асинхронно загружаем изображение
  const image = new Image();
  image.src = url;
  image.addEventListener('load', function() {
    // Теперь, когда изображение загружено, копируем его в текстуру.
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    // предполагаем, что эта текстура имеет размер степени 2
    gl.generateMipmap(gl.TEXTURE_2D);
    render();
  });
  return texture;
}

const imageTexture = loadImageTexture('resources/f-texture.png');
</code></pre>
<p>Вспомним из <a href="webgl-visualizing-the-camera.html">статьи о визуализации камеры</a>,
мы создали куб от -1 до +1 и нарисовали его, чтобы представить усечённую пирамиду камеры.
Наши матрицы сделали так, что пространство внутри этой пирамиды представляет некоторую
область в форме усечённой пирамиды в мировом пространстве, которая преобразуется
из этого мирового пространства в clip space от -1 до +1. Мы можем сделать аналогичную вещь здесь.</p>
<p>Давайте попробуем. Сначала в нашем фрагментном шейдере мы будем рисовать спроецированную текстуру
везде, где её текстурные координаты находятся между 0.0 и 1.0.
За пределами этого диапазона мы будем использовать текстуру-шахматку.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const fs = `#version 300 es
precision highp float;

// Передано из вершинного шейдера.
in vec2 v_texcoord;
in vec4 v_projectedTexcoord;

uniform vec4 u_colorMult;
uniform sampler2D u_texture;
uniform sampler2D u_projectedTexture;

out vec4 outColor;

void main() {
  // делим на w, чтобы получить правильное значение. См. статью о перспективе
  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;

  bool inRange = 
      projectedTexcoord.x &gt;= 0.0 &amp;&amp;
      projectedTexcoord.x &lt;= 1.0 &amp;&amp;
      projectedTexcoord.y &gt;= 0.0 &amp;&amp;
      projectedTexcoord.y &lt;= 1.0;

  vec4 projectedTexColor = texture(u_projectedTexture, projectedTexcoord.xy);
  vec4 texColor = texture(u_texture, v_texcoord) * u_colorMult;

  float projectedAmount = inRange ? 1.0 : 0.0;
  outColor = mix(texColor, projectedTexColor, projectedAmount);
}
`;
</code></pre>
<p>Для вычисления спроецированных текстурных координат мы создадим
матрицу, которая представляет 3D пространство, ориентированное и позиционированное
в определённом направлении, точно так же, как камера из <a href="webgl-visualizing-the-camera.html">статьи о визуализации камеры</a>.
Затем мы спроецируем мировые позиции
вершин сферы и плоскости через это пространство. Там, где
они находятся между 0 и 1, код, который мы только что написали, покажет
текстуру.</p>
<p>Давайте добавим код в вершинный шейдер для проецирования мировых позиций
сферы и плоскости через это <em>пространство</em>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `#version 300 es
in vec4 a_position;
in vec2 a_texcoord;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform mat4 u_textureMatrix;

out vec2 v_texcoord;
out vec4 v_projectedTexcoord;

void main() {
  vec4 worldPosition = u_world * a_position;

  gl_Position = u_projection * u_view * worldPosition;

  // Передаём текстурные координаты во фрагментный шейдер.
  v_texcoord = a_texcoord;

  v_projectedTexcoord = u_textureMatrix * worldPosition;
}
`;
</code></pre>
<p>Теперь всё, что осталось — это фактически вычислить матрицу, которая
определяет это ориентированное пространство. Всё, что нам нужно сделать — это вычислить
мировую матрицу, как мы бы делали для любого другого объекта, а затем взять
её обратную. Это даст нам матрицу, которая позволяет нам ориентировать
мировые позиции других объектов относительно этого пространства.
Это точно то же самое, что делает матрица вида из
<a href="webgl-3d-camera.html">статьи о камерах</a>.</p>
<p>Мы будем использовать нашу функцию <code class="notranslate" translate="no">lookAt</code>, которую мы создали в <a href="webgl-3d-camera.html">той же статье</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
  posX: 3.5,
  posY: 4.4,
  posZ: 4.7,
  targetX: 0.8,
  targetY: 0,
  targetZ: 4.7,
};

function drawScene(projectionMatrix, cameraMatrix) {
  // Получаем view-матрицу из матрицы камеры.
  const viewMatrix = m4.inverse(cameraMatrix);

  let textureWorldMatrix = m4.lookAt(
      [settings.posX, settings.posY, settings.posZ],          // позиция
      [settings.targetX, settings.targetY, settings.targetZ], // цель
      [0, 1, 0],                                              // up
  );
  textureWorldMatrix = m4.scale(
      textureWorldMatrix,
      settings.projWidth, settings.projHeight, 1,
  );

  // используем обратную этой мировой матрицы, чтобы сделать
  // матрицу, которая будет преобразовывать другие позиции
  // относительно этого мирового пространства.
  const textureMatrix = m4.inverse(textureWorldMatrix);

  // устанавливаем uniforms, которые одинаковы для сферы и плоскости
  twgl.setUniforms(textureProgramInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
    u_textureMatrix: textureMatrix,
    u_projectedTexture: imageTexture,
  });

  // ------ Рисуем сферу --------

  // Настраиваем все нужные атрибуты.
  gl.bindVertexArray(sphereVAO);

  // Устанавливаем uniforms, уникальные для сферы
  twgl.setUniforms(textureProgramInfo, sphereUniforms);

  // вызывает gl.drawArrays или gl.drawElements
  twgl.drawBufferInfo(gl, sphereBufferInfo);

  // ------ Рисуем плоскость --------

  // Настраиваем все нужные атрибуты.
  gl.bindVertexArray(planeVAO);

  // Устанавливаем uniforms, уникальные для плоскости
  twgl.setUniforms(textureProgramInfo, planeUniforms);

  // вызывает gl.drawArrays или gl.drawElements
  twgl.drawBufferInfo(gl, planeBufferInfo);

  // ------ Рисуем каркасный куб --------

  gl.useProgram(colorProgramInfo.program);

  // Настраиваем все нужные атрибуты.
  gl.bindVertexArray(cubeLinesVAO);

  // Устанавливаем uniforms для каркасного куба
  twgl.setUniforms(colorProgramInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
    u_world: textureWorldMatrix,
    u_color: [1, 1, 1, 1],  // белый
  });

  // Рисуем линии
  gl.drawElements(gl.LINES, cubeLinesBufferInfo.numElements, gl.UNSIGNED_SHORT, 0);
}
</code></pre>
<p>Конечно, вам не обязательно использовать <code class="notranslate" translate="no">lookAt</code>. Вы можете создать
мировую матрицу любым выбранным способом, например, используя
<a href="webgl-scene-graph.html">граф сцены</a> или <a href="webgl-2d-matrix-stack.html">стек матриц</a>.</p>
<p>Перед тем как запустить, давайте добавим какой-то масштаб.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
  posX: 3.5,
  posY: 4.4,
  posZ: 4.7,
  targetX: 0.8,
  targetY: 0,
  targetZ: 4.7,
  projWidth: 2,
  projHeight: 2,
};

function drawScene(projectionMatrix, cameraMatrix) {
  // Получаем view-матрицу из матрицы камеры.
  const viewMatrix = m4.inverse(cameraMatrix);

  let textureWorldMatrix = m4.lookAt(
      [settings.posX, settings.posY, settings.posZ],          // позиция
      [settings.targetX, settings.targetY, settings.targetZ], // цель
      [0, 1, 0],                                              // up
  );
  textureWorldMatrix = m4.scale(
      textureWorldMatrix,
      settings.projWidth, settings.projHeight, 1,
  );

  // используем обратную этой мировой матрицы, чтобы сделать
  // матрицу, которая будет преобразовывать другие позиции
  // относительно этого мирового пространства.
  const textureMatrix = m4.inverse(textureWorldMatrix);

  ...
}
</code></pre>
<p>И с этим мы получаем спроецированную текстуру.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Я думаю, может быть трудно увидеть пространство, в котором находится текстура.
Давайте добавим каркасный куб для визуализации.</p>
<p>Сначала нам нужен отдельный набор шейдеров. Эти шейдеры
могут просто рисовать сплошной цвет, без текстур.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const colorVS = `#version 300 es
in vec4 a_position;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

void main() {
  // Умножаем позицию на матрицы.
  gl_Position = u_projection * u_view * u_world * a_position;
}
`;
</code></pre>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const colorFS = `#version 300 es
precision highp float;

uniform vec4 u_color;

out vec4 outColor;

void main() {
  outColor = u_color;
}
`;
</code></pre>
<p>Затем нам нужно скомпилировать и связать эти шейдеры тоже.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// настройка GLSL программ
const textureProgramInfo = twgl.createProgramInfo(gl, [vs, fs]);
const colorProgramInfo = twgl.createProgramInfo(gl, [colorVS, colorFS]);
</code></pre>
<p>И нам нужны данные для рисования куба из линий.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const sphereBufferInfo = primitives.createSphereBufferInfo(
    gl,
    1,  // радиус
    12, // делений по кругу
    6,  // делений по высоте
);
const sphereVAO = twgl.createVAOFromBufferInfo(
    gl, textureProgramInfo, sphereBufferInfo);
const planeBufferInfo = primitives.createPlaneBufferInfo(
    gl,
    20,  // ширина
    20,  // высота
    1,   // делений по ширине
    1,   // делений по высоте
);
const planeVAO = twgl.createVAOFromBufferInfo(
    gl, textureProgramInfo, planeBufferInfo);
</code></pre>
<p>Теперь давайте создадим данные для каркасного куба.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Создаём данные для каркасного куба
const cubeLinesBufferInfo = twgl.createBufferInfoFromArrays(gl, {
  position: {
    numComponents: 3,
    data: [
      // передняя грань
      -1, -1,  1,
       1, -1,  1,
       1,  1,  1,
      -1,  1,  1,
      // задняя грань
      -1, -1, -1,
       1, -1, -1,
       1,  1, -1,
      -1,  1, -1,
    ],
  },
  indices: {
    numComponents: 2,
    data: [
      // передняя грань
      0, 1,  1, 2,  2, 3,  3, 0,
      // задняя грань
      4, 5,  5, 6,  6, 7,  7, 4,
      // соединяющие линии
      0, 4,  1, 5,  2, 6,  3, 7,
    ],
  },
});
const cubeLinesVAO = twgl.createVAOFromBufferInfo(
    gl, colorProgramInfo, cubeLinesBufferInfo);
</code></pre>
<p>Теперь давайте добавим код для рисования каркасного куба в нашу функцию <code class="notranslate" translate="no">drawScene</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawScene(projectionMatrix, cameraMatrix) {
  // Получаем view-матрицу из матрицы камеры.
  const viewMatrix = m4.inverse(cameraMatrix);

  let textureWorldMatrix = m4.lookAt(
      [settings.posX, settings.posY, settings.posZ],          // позиция
      [settings.targetX, settings.targetY, settings.targetZ], // цель
      [0, 1, 0],                                              // up
  );
  textureWorldMatrix = m4.scale(
      textureWorldMatrix,
      settings.projWidth, settings.projHeight, 1,
  );

  // используем обратную этой мировой матрицы, чтобы сделать
  // матрицу, которая будет преобразовывать другие позиции
  // относительно этого мирового пространства.
  const textureMatrix = m4.inverse(textureWorldMatrix);

  // устанавливаем uniforms, которые одинаковы для сферы и плоскости
  twgl.setUniforms(textureProgramInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
    u_textureMatrix: textureMatrix,
    u_projectedTexture: imageTexture,
  });

  // ------ Рисуем сферу --------

  // Настраиваем все нужные атрибуты.
  gl.bindVertexArray(sphereVAO);

  // Устанавливаем uniforms, уникальные для сферы
  twgl.setUniforms(textureProgramInfo, sphereUniforms);

  // вызывает gl.drawArrays или gl.drawElements
  twgl.drawBufferInfo(gl, sphereBufferInfo);

  // ------ Рисуем плоскость --------

  // Настраиваем все нужные атрибуты.
  gl.bindVertexArray(planeVAO);

  // Устанавливаем uniforms, уникальные для плоскости
  twgl.setUniforms(textureProgramInfo, planeUniforms);

  // вызывает gl.drawArrays или gl.drawElements
  twgl.drawBufferInfo(gl, planeBufferInfo);

  // ------ Рисуем каркасный куб --------

  gl.useProgram(colorProgramInfo.program);

  // Настраиваем все нужные атрибуты.
  gl.bindVertexArray(cubeLinesVAO);

  // Устанавливаем uniforms для каркасного куба
  twgl.setUniforms(colorProgramInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
    u_world: textureWorldMatrix,
    u_color: [1, 1, 1, 1],  // белый
  });

  // Рисуем линии
  gl.drawElements(gl.LINES, cubeLinesBufferInfo.numElements, gl.UNSIGNED_SHORT, 0);
}
</code></pre>
<p>И с этим мы получаем каркасный куб, который показывает пространство проекции.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection-with-lines.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection-with-lines.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Теперь вы можете видеть каркасный куб, который показывает, где проецируется текстура.
Вы можете изменить настройки, чтобы переместить проектор и изменить его ориентацию.</p>
<p>Это планарное проекционное отображение. Текстура проецируется как плоскость.
Если вы хотите перспективное проекционное отображение, где текстура увеличивается
с расстоянием, вам нужно будет изменить матрицу проекции.</p>
<p>Для перспективного проекционного отображения вы можете использовать
матрицу перспективы вместо ортографической матрицы в <code class="notranslate" translate="no">u_textureMatrix</code>.
Это создаст эффект, где текстура увеличивается с расстоянием от проектора,
точно так же, как настоящий кинопроектор.</p>
<p>Проекционное отображение — это мощная техника для создания
реалистичных эффектов, таких как проецирование изображений на стены,
создание голографических эффектов или добавление динамического освещения
к статическим объектам.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-planar-projection-mapping.html" >English</a>
    <option value="/webgl/lessons/de/webgl-planar-projection-mapping.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-planar-projection-mapping.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-planar-projection-mapping.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-planar-projection-mapping.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-planar-projection-mapping.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-planar-projection-mapping.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-getting-webgl2.html">Как использовать WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как это работает</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 Диаграмма состояния</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl2-whats-new.html">Что нового в WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2.html">Переход с WebGL1 на WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2-fundamentals.html">Отличия от WebGLFundamentals.org до WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продвинутая обработка изображений</a></li>
        </ul>
  <li>2D трансформации, повороты, масштабирование и матричные операции</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D Трансляция</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D Вращение</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D Масштабирование</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D Матрицы</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">Ортографическая 3D</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">3D Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">3D - Камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-naming.html">3D - Именование матриц</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
        </ul>
  <li>Организация и рефакторинг</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">Меньше кода, больше удовольствия</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">Рисование множественных объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">Графы сцен</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">3D Геометрия - Токарная обработка</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Загрузка .obj файлов</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Загрузка .obj с .mtl файлами</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">Использование 2 или более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">Перспективно-корректное наложение текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Планарное и перспективное проекционное отображение</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
        </ul>
  <li>Тени</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Тени</a></li>
        </ul>
  <li>Техники</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">2D - Стек Матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Спрайты</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Кубические карты</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Карты окружения</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Скайбоксы</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Скининг</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Выбор объектов (клик по объектам)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">Текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">Текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">Текст - Использование текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">Текст - Использование текстуры глифов</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Самые маленькие программы</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Рисование без данных</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Вытягивание вершин</a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Индексированные вершины (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Инстансинг (Instanced Drawing)</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">Настройка и установка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Точки, линии и треугольники</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Множественные виды, множественные canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL2 и альфа-канал</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">2D против 3D библиотек</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">Анти-паттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL2 Матрицы против математических матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Проблемы точности</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Скриншот канваса</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Как не очищать канвас</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Получение ввода с клавиатуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Использование WebGL2 как фона в HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Справочник</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Атрибуты</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Текстурные юниты</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">Ссылки</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API документация</a></li>
  <li><a href="https://twgljs.org">TWGL, легковесная библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Есть предложения или замечания? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Создайте issue на GitHub</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Планарное и перспективное проекционное отображение';
            var disqus_title = 'WebGL2 Планарное и перспективное проекционное отображение';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Спасибо <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>за <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} вкладов</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



