<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-2d-matrices.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Как работает матричная математика, объяснено простыми и понятными инструкциями.">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-2d-matrices_ru.jpg">

<meta property="og:title" content="WebGL2 2D Матрицы">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-2d-matrices_ru.jpg">
<meta property="og:description" content="Как работает матричная математика, объяснено простыми и понятными инструкциями.">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-2d-matrices.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 2D Матрицы">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-2d-matrices.html">
<meta name="twitter:description" content="Как работает матричная математика, объяснено простыми и понятными инструкциями.">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-2d-matrices_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-2d-matrices.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-2d-matrices_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-2d-matrices.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-2d-matrices.html",
      "inLanguage":"ru",
      "name":"WebGL2 2D Матрицы",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-2d-matrices.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 2D Матрицы</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-2d-matrices.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-2d-matrices.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-2d-matrices.html" >English</a>
    <option value="/webgl/lessons/de/webgl-2d-matrices.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-2d-matrices.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-2d-matrices.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-2d-matrices.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-2d-matrices.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-2d-matrices.html" >简体中文</a>
</select>


    <a href="#toc">Содержание</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 2D Матрицы</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Этот пост является продолжением серии постов о WebGL. Первый
<a href="webgl-fundamentals.html">начался с основ</a>, а предыдущий
был <a href="webgl-2d-scale.html">о масштабировании 2D геометрии</a>.</p>
<div class="webgl_bottombar">
<h3>Математика vs Программирование vs WebGL</h3>
<p>
Прежде чем мы начнем, если вы ранее изучали линейную алгебру или в целом
имеете опыт работы с матрицами, то
<a href="webgl-matrix-vs-math.html"><b>пожалуйста, прочитайте эту статью перед
продолжением ниже.</b></a>.
</p>
<p>
Если у вас мало или нет опыта с матрицами, то смело
пропустите ссылку выше пока и продолжайте чтение.
</p>
</div>
<p>В последних 3 постах мы прошли, как <a href="webgl-2d-translation.html">перемещать геометрию</a>,
<a href="webgl-2d-rotation.html">поворачивать геометрию</a> и <a href="webgl-2d-scale.html">масштабировать геометрию</a>.
Перемещение, поворот и масштабирование каждый считается типом ‘преобразования’.
Каждое из этих преобразований требовало изменений в шейдере, и каждое
из 3 преобразований зависело от порядка.
В <a href="webgl-2d-scale.html">нашем предыдущем примере</a> мы масштабировали, затем поворачивали,
затем перемещали. Если бы мы применили их в другом порядке, мы получили бы
другой результат.</p>
<p>Например, вот масштабирование 2, 1, поворот на 30 градусов
и перемещение на 100, 0.</p>
<img src="../../resources/f-scale-rotation-translation.svg" class="webgl_center" width="400" />
<p>А вот перемещение на 100,0, поворот на 30 градусов и масштабирование 2, 1</p>
<img src="../../resources/f-translation-rotation-scale.svg" class="webgl_center" width="400" />
<p>Результаты совершенно разные. Еще хуже, если бы нам нужен был
второй пример, нам пришлось бы написать другой шейдер, который применял
перемещение, поворот и масштабирование в нашем новом желаемом порядке.</p>
<p>Ну, некоторые люди намного умнее меня поняли, что вы можете делать
всё то же самое с матричной математикой. Для 2D мы используем матрицу 3x3.
Матрица 3x3 похожа на сетку с 9 ячейками:</p>
<link href="../resources/webgl-2d-matrices.css" rel="stylesheet">
<div class="glocal-center"><table class="glocal-center-content glocal-mat"><tr><td>1.0</td><td>2.0</td><td>3.0</td></tr><tr><td>4.0</td><td>5.0</td><td>6.0</td></tr><tr><td>7.0</td><td>8.0</td><td>9.0</td></tr></table></div>
<p>Для выполнения математики мы умножаем позицию вниз по столбцам матрицы
и складываем результаты. Наши позиции имеют только 2 значения, x и y, но
для выполнения этой математики нам нужно 3 значения, поэтому мы будем использовать 1 для третьего значения.</p>
<p>В этом случае наш результат будет</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col class="glocal-b"/>
<tr><td class="glocal-right">newX&nbsp;=&nbsp;</td><td>x&nbsp;*&nbsp;</td><td class="glocal-border">1.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">newY&nbsp;=&nbsp;</td><td>x&nbsp;*&nbsp;</td><td class="glocal-border">2.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td>x&nbsp;*&nbsp;</td><td class="glocal-border">3.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>y&nbsp;*&nbsp;</td><td class="glocal-border">4.0</td><td class="glocal-left">&nbsp;+</td><td></td><td>y&nbsp;*&nbsp;</td><td class="glocal-border">5.0</td><td class="glocal-left">&nbsp;+&nbsp;</td><td></td><td>y&nbsp;*&nbsp;</td><td class="glocal-border">6.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>1&nbsp;*&nbsp;</td><td>7.0</td><td>&nbsp;</td><td></td><td>1&nbsp;*&nbsp;</td><td>8.0</td><td>&nbsp;&nbsp;</td><td></td><td>1&nbsp;*&nbsp;</td><td>9.0</td><td>&nbsp;</td></tr></table></div>
<p>Вы, вероятно, смотрите на это и думаете “В ЧЕМ СМЫСЛ?” Ну,
давайте предположим, что у нас есть перемещение. Мы назовем количество, на которое мы хотим
переместить, tx и ty. Давайте сделаем матрицу так:</p>
<div class="glocal-center"><table class="glocal-center-content glocal-mat"><tr><td>1.0</td><td>0.0</td><td>0.0</td></tr><tr><td>0.0</td><td>1.0</td><td>0.0</td></tr><tr><td>tx</td><td>ty</td><td>1.0</td></tr></table></div>
<p>И теперь посмотрите</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>newX&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">1.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">newY&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr><tr><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td class="glocal-left">&nbsp;+</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">1.0</td><td class="glocal-left">&nbsp;+&nbsp;</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>tx</td><td>&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>ty</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>1.0</td><td>&nbsp;</td></tr></table></div>
<p>Если вы помните свою алгебру, мы можем удалить любое место, которое умножается
на ноль. Умножение на 1 эффективно ничего не делает, поэтому давайте упростим,
чтобы увидеть, что происходит</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>newX&nbsp;=&nbsp;</td><td>x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">1.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">newY&nbsp;=&nbsp;</td><td class="glocal-blk">x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td class="glocal-blk">x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td class="glocal-blk">y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk glocal-left">&nbsp;+</td><td></td><td>y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-border">1.0</td><td class="glocal-left">&nbsp;+&nbsp;</td><td></td><td class="glocal-blk">y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td>tx</td><td>&nbsp;</td><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td>ty</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">1.0</td><td>&nbsp;</td></tr></table></div>
<p>или более кратко</p>
<div class="webgl_center"><pre class="webgl_math">
newX = x + tx;
newY = y + ty;
</pre></div>
<p>И extra нас не очень волнует. Это выглядит удивительно похоже на
<a href="webgl-2d-translation.html">код перемещения из нашего примера перемещения</a>.</p>
<p>Аналогично давайте сделаем поворот. Как мы указали в посте о повороте,
нам просто нужны синус и косинус угла, на который мы хотим повернуть, поэтому</p>
<div class="webgl_center"><pre class="webgl_math">
s = Math.sin(angleToRotateInRadians);
c = Math.cos(angleToRotateInRadians);
</pre></div>
<p>И мы строим матрицу так</p>
<div class="glocal-center"><table class="glocal-center-content glocal-mat"><tr><td>c</td><td>-s</td><td>0.0</td></tr><tr><td>s</td><td>c</td><td>0.0</td></tr><tr><td>0.0</td><td>0.0</td><td>1.0</td></tr></table></div>
<p>Применяя матрицу, мы получаем это</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>newX&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">c</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">newY&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">-s</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">s</td><td class="glocal-left">&nbsp;+</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">c</td><td class="glocal-left">&nbsp;+&nbsp;</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>0.0</td><td>&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>0.0</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>1.0</td><td>&nbsp;</td></tr></table></div>
<p>Зачеркивая все умножения на 0 и 1, мы получаем</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>newX&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">c</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">newY&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">-s</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td class="glocal-blk">x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">s</td><td class="glocal-left glocal-blk">&nbsp;+</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">c</td><td class="glocal-left glocal-blk">&nbsp;+&nbsp;</td><td></td><td class="glocal-blk">y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">0.0</td><td>&nbsp;</td><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">0.0</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">1.0</td><td>&nbsp;</td></tr></table></div>
<p>И упрощая, мы получаем</p>
<pre class="webgl_center">
newX = x *  c + y * s;
newY = x * -s + y * c;
</pre>
<p>Что точно то же, что у нас было в <a href="webgl-2d-rotation.html">примере поворота</a>.</p>
<p>И наконец масштабирование. Мы назовем наши 2 фактора масштабирования sx и sy</p>
<p>И мы строим матрицу так</p>
<div class="glocal-center"><table class="glocal-center-content glocal-mat"><tr><td>sx</td><td>0.0</td><td>0.0</td></tr><tr><td>0.0</td><td>sy</td><td>0.0</td></tr><tr><td>0.0</td><td>0.0</td><td>1.0</td></tr></table></div>
<p>Применяя матрицу, мы получаем это</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>newX&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">sx</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">newY&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td class="glocal-left">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td class="glocal-left">&nbsp;+</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">sy</td><td class="glocal-left">&nbsp;+&nbsp;</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td>&nbsp;+</td></tr>
<tr><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>0.0</td><td>&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>0.0</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td>&nbsp;*&nbsp;</td><td>1.0</td><td>&nbsp;</td></tr></table></div>
<p>что на самом деле</p>
<div class="glocal-center"><table class="glocal-center-content">
<col/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/><col/><col class="glocal-sp"/><col/><col/><col class="glocal-b"/>
<tr><td>newX&nbsp;=&nbsp;</td><td>x</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">sx</td><td class="glocal-left glocal-blk">&nbsp;+</td><td class="glocal-right">newY&nbsp;=&nbsp;</td><td class="glocal-blk">x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-left glocal-blk">&nbsp;+</td><td class="glocal-right">extra&nbsp;=&nbsp;</td><td class="glocal-blk">x</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td class="glocal-blk">y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk glocal-border">0.0</td><td class="glocal-left glocal-blk">&nbsp;+</td><td></td><td>y</td><td>&nbsp;*&nbsp;</td><td class="glocal-border">sy</td><td class="glocal-left glocal-blk">&nbsp;+&nbsp;</td><td></td><td class="glocal-blk">y</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-border">0.0</td><td class="glocal-blk">&nbsp;+</td></tr>
<tr><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">0.0</td><td>&nbsp;</td><td></td><td class="glocal-blk">1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">0.0</td><td>&nbsp;&nbsp;</td><td></td><td>1</td><td class="glocal-blk">&nbsp;*&nbsp;</td><td class="glocal-blk">1.0</td><td>&nbsp;</td></tr></table></div>
<p>что упрощенно</p>
<pre class="webgl_center">
newX = x * sx;
newY = y * sy;
</pre>
<p>Что то же самое, что наш <a href="webgl-2d-scale.html">пример масштабирования</a>.</p>
<p>Теперь я уверен, что вы все еще можете думать “И что? В чем смысл?”
Это кажется большой работой только для того, чтобы делать то же самое, что мы уже делали.</p>
<p>Здесь вступает в игру магия. Оказывается, мы можем умножать матрицы
вместе и применять все преобразования сразу. Давайте предположим, что у нас есть
функция <code class="notranslate" translate="no">m3.multiply</code>, которая берет две матрицы, умножает их и
возвращает результат.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var m3 = {
  multiply: function(a, b) {
    var a00 = a[0 * 3 + 0];
    var a01 = a[0 * 3 + 1];
    var a02 = a[0 * 3 + 2];
    var a10 = a[1 * 3 + 0];
    var a11 = a[1 * 3 + 1];
    var a12 = a[1 * 3 + 2];
    var a20 = a[2 * 3 + 0];
    var a21 = a[2 * 3 + 1];
    var a22 = a[2 * 3 + 2];
    var b00 = b[0 * 3 + 0];
    var b01 = b[0 * 3 + 1];
    var b02 = b[0 * 3 + 2];
    var b10 = b[1 * 3 + 0];
    var b11 = b[1 * 3 + 1];
    var b12 = b[1 * 3 + 2];
    var b20 = b[2 * 3 + 0];
    var b21 = b[2 * 3 + 1];
    var b22 = b[2 * 3 + 2];

    return [
      b00 * a00 + b01 * a10 + b02 * a20,
      b00 * a01 + b01 * a11 + b02 * a21,
      b00 * a02 + b01 * a12 + b02 * a22,
      b10 * a00 + b11 * a10 + b12 * a20,
      b10 * a01 + b11 * a11 + b12 * a21,
      b10 * a02 + b11 * a12 + b12 * a22,
      b20 * a00 + b21 * a10 + b22 * a20,
      b20 * a01 + b21 * a11 + b22 * a21,
      b20 * a02 + b21 * a12 + b22 * a22,
    ];
  }
}
</code></pre>
<p>Чтобы сделать вещи более ясными, давайте создадим функции для построения матриц для
перемещения, поворота и масштабирования.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var m3 = {
  translation: function(tx, ty) {
    return [
      1, 0, 0,
      0, 1, 0,
      tx, ty, 1,
    ];
  },

  rotation: function(angleInRadians) {
    var c = Math.cos(angleInRadians);
    var s = Math.sin(angleInRadians);
    return [
      c,-s, 0,
      s, c, 0,
      0, 0, 1,
    ];
  },

  scaling: function(sx, sy) {
    return [
      sx, 0, 0,
      0, sy, 0,
      0, 0, 1,
    ];
  },
};
</code></pre>
<p>Теперь давайте изменим наш шейдер. Старый шейдер выглядел так</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es

in vec2 a_position;

uniform vec2 u_resolution;
uniform vec2 u_translation;
uniform vec2 u_rotation;
uniform vec2 u_scale;

void main() {
  // Масштабируем позицию
  vec2 scaledPosition = a_position * u_scale;

  // Поворачиваем позицию
  vec2 rotatedPosition = vec2(
     scaledPosition.x * u_rotation.y + scaledPosition.y * u_rotation.x,
     scaledPosition.y * u_rotation.y - scaledPosition.x * u_rotation.x);

  // Добавляем перемещение.
  vec2 position = rotatedPosition + u_translation;
</code></pre>
<p>Наш новый шейдер будет намного проще.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es

in vec2 a_position;

uniform vec2 u_resolution;
uniform mat3 u_matrix;

void main() {
  // Умножаем позицию на матрицу.
  vec2 position = (u_matrix * vec3(a_position, 1)).xy;
  ...
</code></pre>
<p>И вот как мы его используем</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // Рисуем сцену.
  function drawScene() {
    webglUtils.resizeCanvasToDisplaySize(gl.canvas);

    // Говорим WebGL, как конвертировать из clip space в пиксели
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    // Очищаем холст
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Говорим использовать нашу программу (пару шейдеров)
    gl.useProgram(program);

    // Привязываем набор атрибутов/буферов, который мы хотим.
    gl.bindVertexArray(vao);

    // Вычисляем матрицы
    var projectionMatrix = m3.projection(
        gl.canvas.clientWidth, gl.canvas.clientHeight);
    var translationMatrix = m3.translation(translation[0], translation[1]);
    var rotationMatrix = m3.rotation(rotationInRadians);
    var scaleMatrix = m3.scaling(scale[0], scale[1]);

    // Умножаем матрицы.
    var matrix = m3.multiply(projectionMatrix, translationMatrix);
    matrix = m3.multiply(matrix, rotationMatrix);
    matrix = m3.multiply(matrix, scaleMatrix);

    // Устанавливаем матрицу.
    gl.uniformMatrix3fv(matrixLocation, false, matrix);

    // Устанавливаем цвет.
    gl.uniform4fv(colorLocation, color);

    // Рисуем прямоугольник.
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 18;
    gl.drawArrays(primitiveType, offset, count);
  }
</code></pre>
<p>Вот пример использования нашего нового кода. Слайдеры те же, перемещение,
поворот и масштабирование. Но способ их использования в шейдере намного проще.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-geometry-matrix-transform.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-geometry-matrix-transform.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Все еще, вы можете спрашивать, и что? Это не кажется большой выгодой.
Но теперь, если мы хотим изменить порядок, нам не нужно писать новый шейдер.
Мы можем просто изменить математику.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">    ...
    // Умножаем матрицы.
    var matrix = m3.multiply(scaleMatrix, rotationMatrix);
    matrix = m3.multiply(matrix, translationMatrix);
    ...
</code></pre>
<p>Вот эта версия.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-geometry-matrix-transform-trs.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-geometry-matrix-transform-trs.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Возможность применять матрицы таким образом особенно важна для
иерархической анимации, как руки на теле, луны на планете вокруг
солнца, или ветви на дереве. Для простого примера иерархической
анимации давайте нарисуем нашу ‘F’ 5 раз, но каждый раз давайте начнем с
матрицы от предыдущей ‘F’.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">    // Рисуем сцену.
    function drawScene() {

      ...

      // Вычисляем матрицы
      var translationMatrix = m3.translation(translation[0], translation[1]);
      var rotationMatrix = m3.rotation(rotationInRadians);
      var scaleMatrix = m3.scaling(scale[0], scale[1]);

      // Начальная матрица.
      var matrix = m3.identity();

      for (var i = 0; i &lt; 5; ++i) {
        // Умножаем матрицы.
        matrix = m3.multiply(matrix, translationMatrix);
        matrix = m3.multiply(matrix, rotationMatrix);
        matrix = m3.multiply(matrix, scaleMatrix);

        // Устанавливаем матрицу.
        gl.uniformMatrix3fv(matrixLocation, false, matrix);

        // Рисуем геометрию.
        var primitiveType = gl.TRIANGLES;
        var offset = 0;
        var count = 18;
        gl.drawArrays(primitiveType, offset, count);
      }
    }
</code></pre>
<p>Для этого мы ввели функцию <code class="notranslate" translate="no">m3.identity</code>, которая создает
единичную матрицу. Единичная матрица - это матрица, которая эффективно представляет
1.0, так что если вы умножаете на единичную матрицу, ничего не происходит. Так же как</p>
<div class="webgl_center">X * 1 = X</div>
<p>так и</p>
<div class="webgl_center">matrixX * identity = matrixX</div>
<p>Вот код для создания единичной матрицы.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var m3 = {
  identity: function () {
    return [
      1, 0, 0,
      0, 1, 0,
      0, 0, 1,
    ];
  },
};
</code></pre>
<p>Вот 5 F.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-geometry-matrix-transform-hierarchical.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-geometry-matrix-transform-hierarchical.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Давайте посмотрим еще один пример. Во всех примерах до сих пор наша ‘F’ вращается вокруг своего
верхнего левого угла. Это потому, что математика, которую мы используем, всегда вращается вокруг
начала координат, а верхний левый угол нашей ‘F’ находится в начале координат, (0, 0).</p>
<p>Но теперь, поскольку мы можем делать матричную математику и можем выбирать порядок, в котором
применяются преобразования, мы можем эффективно переместить начало координат перед тем, как остальные
преобразования будут применены.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">    // создаем матрицу, которая переместит начало координат 'F' в его центр.
    var moveOriginMatrix = m3.translation(-50, -75);
    ...

    // Умножаем матрицы.
    var matrix = m3.multiply(translationMatrix, rotationMatrix);
    matrix = m3.multiply(matrix, scaleMatrix);
    matrix = m3.multiply(matrix, moveOriginMatrix);
</code></pre>
<p>Вот этот пример. Обратите внимание, что F вращается и масштабируется вокруг центра.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-geometry-matrix-transform-center-f.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-geometry-matrix-transform-center-f.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Используя эту технику, вы можете вращать или масштабировать из любой точки. Теперь вы знаете,
как Photoshop или Flash позволяют вам перемещать точку вращения какого-то изображения.</p>
<p>Давайте пойдем еще дальше. Если вы вернетесь к первой статье о
<a href="webgl-fundamentals.html">основах WebGL</a>, вы можете вспомнить, что у нас есть код
в шейдере для конвертации из пикселей в clip space, который выглядит так.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">  ...
  // конвертируем прямоугольник из пикселей в 0.0 до 1.0
  vec2 zeroToOne = position / u_resolution;

  // конвертируем из 0-&gt;1 в 0-&gt;2
  vec2 zeroToTwo = zeroToOne * 2.0;

  // конвертируем из 0-&gt;2 в -1-&gt;+1 (clip space)
  vec2 clipSpace = zeroToTwo - 1.0;

  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
</code></pre>
<p>Если вы посмотрите на каждый из этих шагов по очереди, первый шаг,
“конвертируем из пикселей в 0.0 до 1.0”, на самом деле является операцией масштабирования.
Второй также является операцией масштабирования. Следующий - это перемещение,
и самый последний масштабирует Y на -1. Мы можем на самом деле сделать все это в
матрице, которую мы передаем в шейдер. Мы могли бы создать 2 матрицы масштабирования,
одну для масштабирования на 1.0/resolution, другую для масштабирования на 2.0, третью для
перемещения на -1.0,-1.0 и четвертую для масштабирования Y на -1, затем умножить
их все вместе, но вместо этого, поскольку математика простая,
мы просто создадим функцию, которая создает матрицу ‘проекции’ для
заданного разрешения напрямую.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var m3 = {
  projection: function (width, height) {
    // Примечание: Эта матрица переворачивает ось Y так, что 0 находится сверху.
    return [
      2 / width, 0, 0,
      0, -2 / height, 0,
      -1, 1, 1,
    ];
  },
  ...
</code></pre>
<p>Теперь мы можем упростить шейдер еще больше. Вот весь новый вершинный шейдер.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

in vec2 a_position;

uniform mat3 u_matrix;

void main() {
  // Умножаем позицию на матрицу.
  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
}
</code></pre>
<p>И в JavaScript нам нужно умножить на матрицу проекции</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // Рисуем сцену.
  function drawScene() {
    ...
-    // Передаем разрешение холста, чтобы мы могли конвертировать из
-    // пикселей в clip space в шейдере
-    gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);

    ...

    // Вычисляем матрицы
    var projectionMatrix = m3.projection(
        gl.canvas.clientWidth, gl.canvas.clientHeight);
    var translationMatrix = m3.translation(translation[0], translation[1]);
    var rotationMatrix = m3.rotation(rotationInRadians);
    var scaleMatrix = m3.scaling(scale[0], scale[1]);

    // Умножаем матрицы.
*    var matrix = m3.multiply(projectionMatrix, translationMatrix);
*    matrix = m3.multiply(matrix, rotationMatrix);
    matrix = m3.multiply(matrix, scaleMatrix);
    ...
  }
</code></pre>
<p>Мы также удалили код, который устанавливал разрешение. С этим последним шагом мы перешли
от довольно сложного шейдера с 6-7 шагами к очень простому шейдеру только с
1 шагом, все благодаря магии матричной математики.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-geometry-matrix-transform-with-projection.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-geometry-matrix-transform-with-projection.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Прежде чем мы продолжим, давайте немного упростим. Хотя обычно генерировать
различные матрицы и отдельно умножать их вместе, также обычно просто
умножать их по ходу дела. Эффективно мы могли бы функции как эти</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">var m3 = {

  ...

  translate: function(m, tx, ty) {
    return m3.multiply(m, m3.translation(tx, ty));
  },

  rotate: function(m, angleInRadians) {
    return m3.multiply(m, m3.rotation(angleInRadians));
  },

  scale: function(m, sx, sy) {
    return m3.multiply(m, m3.scaling(sx, sy));
  },

  ...

};
</code></pre>
<p>Это позволило бы нам изменить 7 строк матричного кода выше на всего 4 строки, как эти</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Вычисляем матрицу
var matrix = m3.projection(gl.canvas.clientWidth, gl.canvas.clientHeight);
matrix = m3.translate(matrix, translation[0], translation[1]);
matrix = m3.rotate(matrix, rotationInRadians);
matrix = m3.scale(matrix, scale[0], scale[1]);
</code></pre>
<p>И вот это</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-2d-geometry-matrix-transform-simpler-functions.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-2d-geometry-matrix-transform-simpler-functions.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Последняя вещь, мы видели выше, что порядок имеет значение. В первом примере у нас было</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">translation * rotation * scale
</code></pre>
<p>а во втором у нас было</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">scale * rotation * translation
</code></pre>
<p>И мы видели, как они разные.</p>
<p>Есть 2 способа смотреть на матрицы. Учитывая выражение</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">projectionMat * translationMat * rotationMat * scaleMat * position
</code></pre>
<p>Первый способ, который многие люди находят естественным, - начать справа и работать
влево</p>
<p>Сначала мы умножаем позицию на матрицу масштабирования, чтобы получить масштабированную позицию</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">scaledPosition = scaleMat * position
</code></pre>
<p>Затем мы умножаем scaledPosition на матрицу поворота, чтобы получить rotatedScaledPosition</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">rotatedScaledPosition = rotationMat * scaledPosition
</code></pre>
<p>Затем мы умножаем rotatedScaledPosition на матрицу перемещения, чтобы получить
translatedRotatedScaledPosition</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">translatedRotatedScaledPosition = translationMat * rotatedScaledPosition
</code></pre>
<p>И наконец мы умножаем это на матрицу проекции, чтобы получить позиции в clip space</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">clipspacePosition = projectionMatrix * translatedRotatedScaledPosition
</code></pre>
<p>Второй способ смотреть на матрицы - читать слева направо. В этом случае
каждая матрица изменяет “пространство”, представленное холстом. Холст начинается
с представления clip space (-1 до +1) в каждом направлении. Каждая примененная матрица
слева направо изменяет пространство, представленное холстом.</p>
<p>Шаг 1: нет матрицы (или единичная матрица)</p>
<blockquote>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/matrix-space-change.html?stage=0"></iframe>
  <div class="webgl_center">clip space</div>
</div>

</p>
<p>Белая область - это холст. Синий - вне холста. Мы в clip space.
Передаваемые позиции должны быть в clip space</p>
</blockquote>
<p>Шаг 2: <code class="notranslate" translate="no">matrix = m3.projection(gl.canvas.clientWidth, gl.canvas.clientHeight)</code>;</p>
<blockquote>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/matrix-space-change.html?stage=1"></iframe>
  <div class="webgl_center">из clip space в pixel space</div>
</div>

</p>
<p>Теперь мы в pixel space. X = 0 до 400, Y = 0 до 300 с 0,0 в верхнем левом углу.
Позиции, передаваемые с использованием этой матрицы, должны быть в pixel space. Вспышка, которую вы видите,
это когда пространство переворачивается с положительного Y = вверх на положительный Y = вниз.</p>
</blockquote>
<p>Шаг 3: <code class="notranslate" translate="no">matrix = m3.translate(matrix, tx, ty);</code></p>
<blockquote>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/matrix-space-change.html?stage=2"></iframe>
  <div class="webgl_center">переместить начало координат в tx, ty</div>
</div>

</p>
<p>Начало координат теперь перемещено в tx, ty (150, 100). Пространство переместилось.</p>
</blockquote>
<p>Шаг 4: <code class="notranslate" translate="no">matrix = m3.rotate(matrix, rotationInRadians);</code></p>
<blockquote>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/matrix-space-change.html?stage=3"></iframe>
  <div class="webgl_center">повернуть на 33 градуса</div>
</div>

</p>
<p>Пространство повернуто вокруг tx, ty</p>
</blockquote>
<p>Шаг 5: <code class="notranslate" translate="no">matrix = m3.scale(matrix, sx, sy);</code></p>
<blockquote>
<p><div class="webgl_diagram_container">
  <iframe class="webgl_example " style="width: 400px; height: 300px;" src="/webgl/lessons/resources/matrix-space-change.html?stage=4"></iframe>
</div>

</p>
<p>Предварительно повернутое пространство с центром в tx, ty масштабировано на 2 по x, 1.5 по y</p>
</blockquote>
<p>В шейдере мы затем делаем <code class="notranslate" translate="no">gl_Position = matrix * position;</code>. Значения <code class="notranslate" translate="no">position</code> эффективно находятся в этом финальном пространстве.</p>
<p>Используйте тот способ, который вам легче понять.</p>
<p>Я надеюсь, что эти посты помогли развеять тайну матричной математики. Если вы хотите
остаться с 2D, я бы предложил проверить <a href="webgl-2d-drawimage.html">воссоздание функции drawImage canvas 2d</a> и следовать за этим
в <a href="webgl-2d-matrix-stack.html">воссоздание матричного стека canvas 2d</a>.</p>
<p>Иначе дальше <a href="webgl-3d-orthographic.html">мы перейдем к 3D</a>.
В 3D матричная математика следует тем же принципам и использованию.
Я начал с 2D, чтобы надеюсь сохранить это простым для понимания.</p>
<p>Также, если вы действительно хотите стать экспертом
в матричной математике <a href="https://www.youtube.com/watch?v=kjBOesZCoqc&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">проверьте эти удивительные видео</a>.</p>
<div class="webgl_bottombar">
<h3>Что такое <code class="notranslate" translate="no">clientWidth</code> и <code class="notranslate" translate="no">clientHeight</code>?</h3>
<p>До этого момента, когда я ссылался на размеры холста,
я использовал <code class="notranslate" translate="no">canvas.width</code> и <code class="notranslate" translate="no">canvas.height</code>,
но выше, когда я вызывал <code class="notranslate" translate="no">m3.projection</code>, я вместо этого использовал
<code class="notranslate" translate="no">canvas.clientWidth</code> и <code class="notranslate" translate="no">canvas.clientHeight</code>.
Почему?</p>
<p>Матрицы проекции касаются того, как взять clip space
(-1 до +1 в каждом измерении) и конвертировать его обратно
в пиксели. Но в браузере есть 2 типа пикселей, с которыми мы
имеем дело. Один - это количество пикселей в
самом холсте. Так, например, холст, определенный так.</p>
<pre class="prettyprint">
  &lt;canvas width="400" height="300"&gt;&lt;/canvas&gt;
</pre>
<p>или один, определенный так</p>
<pre class="prettyprint">
  var canvas = document.createElement("canvas");
  canvas.width = 400;
  canvas.height = 300;
</pre>
<p>оба содержат изображение 400 пикселей в ширину на 300 пикселей в высоту.
Но этот размер отделен от того размера,
который браузер фактически отображает этот 400x300 пиксельный холст.
CSS определяет, какого размера отображается холст.
Например, если мы сделали холст так.</p>
<pre class="prettyprint"><!>
  &lt;style&gt;
  canvas {
    width: 100%;
    height: 100%;
  }
  &lt;/style&gt;
  ...
  &lt;canvas width="400" height="300">&lt;/canvas&gt;
</pre>
<p>Холст будет отображаться любого размера, каким является его контейнер.
Это, вероятно, не 400x300.</p>
<p>Вот два примера, которые устанавливают CSS размер отображения холста на
100%, так что холст растягивается,
чтобы заполнить страницу. Первый использует <code class="notranslate" translate="no">canvas.width</code>
и <code class="notranslate" translate="no">canvas.height</code>. Откройте его в новом
окне и измените размер окна. Обратите внимание, как 'F'
не имеет правильного соотношения сторон. Она искажается.</p>
<div class="webgl_example_container">
  <iframe class="webgl_example" style="width:  500px; height: 150px;" src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-canvas-width-height.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-canvas-width-height.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>


<p>В этом втором примере мы используем <code class="notranslate" translate="no">canvas.clientWidth</code>
и <code class="notranslate" translate="no">canvas.clientHeight</code>. <code class="notranslate" translate="no">canvas.clientWidth</code>
и <code class="notranslate" translate="no">canvas.clientHeight</code> сообщают
размер, который холст фактически отображается браузером, так что
в этом случае, даже хотя холст все еще имеет только 400x300 пикселей,
поскольку мы определяем наше соотношение сторон на основе размера, который холст
отображается, <code class="notranslate" translate="no">F</code> всегда выглядит правильно.</p>
<div class="webgl_example_container">
  <iframe class="webgl_example" style="width:  500px; height: 150px;" src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-canvas-clientwidth-clientheight.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-canvas-clientwidth-clientheight.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>


<p>Большинство приложений, которые позволяют изменять размер их холстов, пытаются сделать
<code class="notranslate" translate="no">canvas.width</code> и <code class="notranslate" translate="no">canvas.height</code> соответствующими
<code class="notranslate" translate="no">canvas.clientWidth</code> и <code class="notranslate" translate="no">canvas.clientHeight</code>,
потому что они хотят, чтобы был
один пиксель в холсте для каждого пикселя, отображаемого браузером.
Но, как мы видели выше, это не
единственный вариант. Это означает, что почти во всех случаях более
технически правильно вычислять
соотношение сторон матрицы проекции, используя <code class="notranslate" translate="no">canvas.clientHeight</code>
и <code class="notranslate" translate="no">canvas.clientWidth</code>. Тогда вы получите правильное соотношение сторон
независимо от того, соответствуют ли ширина и высота холста
размеру, который браузер рисует холст. 
    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-2d-matrices.html" >English</a>
    <option value="/webgl/lessons/de/webgl-2d-matrices.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-2d-matrices.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-2d-matrices.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-2d-matrices.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-2d-matrices.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-2d-matrices.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-getting-webgl2.html">Как использовать WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как это работает</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 Диаграмма состояния</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl2-whats-new.html">Что нового в WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2.html">Переход с WebGL1 на WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2-fundamentals.html">Отличия от WebGLFundamentals.org до WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продвинутая обработка изображений</a></li>
        </ul>
  <li>2D трансформации, повороты, масштабирование и матричные операции</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D Трансляция</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D Вращение</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D Масштабирование</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D Матрицы</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">Ортографическая 3D</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">3D Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">3D - Камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-naming.html">3D - Именование матриц</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
        </ul>
  <li>Организация и рефакторинг</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">Меньше кода, больше удовольствия</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">Рисование множественных объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">Графы сцен</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">3D Геометрия - Токарная обработка</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Загрузка .obj файлов</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Загрузка .obj с .mtl файлами</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">Использование 2 или более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">Перспективно-корректное наложение текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Планарное и перспективное проекционное отображение</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
        </ul>
  <li>Тени</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Тени</a></li>
        </ul>
  <li>Техники</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">2D - Стек Матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Спрайты</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Кубические карты</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Карты окружения</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Скайбоксы</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Скининг</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Выбор объектов (клик по объектам)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">Текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">Текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">Текст - Использование текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">Текст - Использование текстуры глифов</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Самые маленькие программы</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Рисование без данных</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Вытягивание вершин</a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Индексированные вершины (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Инстансинг (Instanced Drawing)</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">Настройка и установка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Точки, линии и треугольники</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Множественные виды, множественные canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL2 и альфа-канал</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">2D против 3D библиотек</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">Анти-паттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL2 Матрицы против математических матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Проблемы точности</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Скриншот канваса</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Как не очищать канвас</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Получение ввода с клавиатуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Использование WebGL2 как фона в HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Справочник</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Атрибуты</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Текстурные юниты</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">Ссылки</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API документация</a></li>
  <li><a href="https://twgljs.org">TWGL, легковесная библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Есть предложения или замечания? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Создайте issue на GitHub</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 2D Матрицы';
            var disqus_title = 'WebGL2 2D Матрицы';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Спасибо <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>за <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} вкладов</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



