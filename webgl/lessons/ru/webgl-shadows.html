<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-shadows.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Как вычислять тени">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadows_ru.jpg">

<meta property="og:title" content="WebGL2 Тени">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadows_ru.jpg">
<meta property="og:description" content="Как вычислять тени">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadows.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Тени">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadows.html">
<meta name="twitter:description" content="Как вычислять тени">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadows_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadows.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shadows_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadows.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadows.html",
      "inLanguage":"ru",
      "name":"WebGL2 Тени",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shadows.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Тени</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-shadows.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-shadows.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-shadows.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-shadows.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-shadows.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-shadows.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shadows.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-shadows.html" >English</a>
    <option value="/webgl/lessons/de/webgl-shadows.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-shadows.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shadows.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-shadows.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-shadows.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shadows.html" >简体中文</a>
</select>


    <a href="#toc">Содержание</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Тени</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Давайте нарисуем некоторые тени!</p>
<h2 id="предварительные-требования">Предварительные требования</h2>
<p>Вычисление базовых теней не <em>так</em> сложно, но требует
много фоновых знаний. Чтобы понять эту статью,
вам нужно уже понимать следующие темы.</p>
<ul>
<li><a href="webgl-3d-orthographic.html">Ортографическая проекция</a></li>
<li><a href="webgl-3d-perspective.html">Перспективная проекция</a></li>
<li><a href="webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
<li><a href="webgl-3d-textures.html">Текстуры</a></li>
<li><a href="webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
<li><a href="webgl-planar-projection-mapping.html">Проекция текстур</a></li>
<li><a href="webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
</ul>
<p>Поэтому, если вы их не читали, пожалуйста, сначала прочитайте их.</p>
<p>Помимо этого, эта статья предполагает, что вы прочитали статью о
<a href="webgl-less-code-more-fun.html">меньше кода больше веселья</a>,
поскольку она использует библиотеку, упомянутую там, чтобы
не загромождать пример. Если вы не понимаете,
что такое буферы, массивы вершин и атрибуты, или когда
функция называется <code class="notranslate" translate="no">twgl.setUniforms</code>, что означает
установка uniforms и т.д., то вам, вероятно, стоит пойти дальше назад и
<a href="webgl-fundamentals.html">прочитать основы</a>.</p>
<p>Итак, во-первых, есть более одного способа рисовать тени.
Каждый способ имеет свои компромиссы. Самый распространенный способ рисовать
тени - использовать карты теней.</p>
<p>Карты теней работают, комбинируя техники из всех предварительных
статей выше.</p>
<p>В <a href="webgl-planar-projection-mapping.html">статье о проекционном маппинге</a>
мы видели, как проецировать изображение на объекты</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-planar-projection-with-projection-matrix.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-planar-projection-with-projection-matrix.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Напомним, что мы не рисовали это изображение поверх объектов в сцене,
скорее, когда объекты рендерились, для каждого пикселя мы проверяли, находится ли
проецируемая текстура в диапазоне, если да, то мы брали соответствующий цвет из
проецируемой текстуры, если нет, то мы брали цвет из другой текстуры,
цвет которой искался с использованием координат текстуры, которые маппили текстуру
на объект.</p>
<p>Что, если проецируемая текстура вместо этого содержала данные глубины с точки
зрения источника света. Другими словами, предположим, что был источник света на кончике
усеченной пирамиды, показанной в том примере выше, и проецируемая текстура имела информацию о глубине
с точки зрения источника света. Сфера имела бы значения глубины ближе
к источнику света, плоскость имела бы значения глубины дальше
от источника света.</p>
<div class="webgl_center"><img class="noinvertdark" src="../resources/depth-map-generation.svg" style="width: 600px;"></div>
<p>Если бы у нас были эти данные, то при выборе цвета для рендеринга
мы могли бы получить значение глубины из проецируемой текстуры и проверить, является ли
глубина пикселя, который мы собираемся нарисовать, ближе или дальше от источника света.
Если она дальше от источника света, это означает, что что-то еще было ближе к источнику света. Другими словами,
что-то блокирует свет, поэтому этот пиксель в тени.</p>
<div class="webgl_center"><img class="noinvertdark" src="../resources/projected-depth-texture.svg" style="width: 600px;"></div>
<p>Здесь текстура глубины проецируется через пространство света внутри усеченной пирамиды с точки зрения источника света.
Когда мы рисуем пиксели пола, мы вычисляем глубину этого пикселя с точки зрения
источника света (0.3 на диаграмме выше). Затем мы смотрим на соответствующую глубину в
проецируемой карте глубины. С точки зрения источника света значение глубины
в текстуре будет 0.1, потому что она попала в сферу. Видя, что 0.1 &lt; 0.3, мы
знаем, что пол в этой позиции должен быть в тени.</p>
<p>Сначала давайте нарисуем карту теней. Мы возьмем последний пример из
<a href="webgl-planar-projection-mapping.html">статьи о проекционном маппинге</a>,
но вместо загрузки текстуры мы будем <a href="webgl-render-to-texture.html">рендерить в текстуру</a>,
поэтому мы создаем текстуру глубины и прикрепляем ее к framebuffer как <code class="notranslate" translate="no">DEPTH_ATTACHMENT</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const depthTexture = gl.createTexture();
const depthTextureSize = 512;
gl.bindTexture(gl.TEXTURE_2D, depthTexture);
gl.texImage2D(
    gl.TEXTURE_2D,      // target
    0,                  // mip level
    gl.DEPTH_COMPONENT32F, // internal format
    depthTextureSize,   // width
    depthTextureSize,   // height
    0,                  // border
    gl.DEPTH_COMPONENT, // format
    gl.FLOAT,           // type
    null);              // data
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

const depthFramebuffer = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
gl.framebufferTexture2D(
    gl.FRAMEBUFFER,       // target
    gl.DEPTH_ATTACHMENT,  // attachment point
    gl.TEXTURE_2D,        // texture target
    depthTexture,         // texture
    0);                   // mip level
</code></pre>
<p>Чтобы использовать это, нам нужно уметь рендерить сцену более одного раза с разными
шейдерами. Один раз с простым шейдером только для рендеринга в текстуру глубины, а
затем снова с нашим текущим шейдером, который проецирует текстуру.</p>
<p>Итак, сначала давайте изменим <code class="notranslate" translate="no">drawScene</code>, чтобы мы могли передать ей программу, с которой хотим
рендерить</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function drawScene(projectionMatrix, cameraMatrix, textureMatrix) {
+function drawScene(projectionMatrix, cameraMatrix, textureMatrix, programInfo) {
  // Создаем матрицу вида из матрицы камеры.
  const viewMatrix = m4.inverse(cameraMatrix);

-  gl.useProgram(textureProgramInfo.program);
+  gl.useProgram(programInfo.program);

  // устанавливаем uniforms, которые одинаковы для сферы и плоскости
  // примечание: любые значения без соответствующего uniform в шейдере
  // игнорируются.
-  twgl.setUniforms(textureProgramInfo, {
+  twgl.setUniforms(programInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
*    u_textureMatrix: textureMatrix,
-    u_projectedTexture: imageTexture,
+    u_projectedTexture: depthTexture,
  });

  // ------ Рисуем сферу --------

  // Настраиваем все необходимые атрибуты.
  gl.bindVertexArray(sphereVAO);

  // Устанавливаем uniforms, уникальные для сферы
-  twgl.setUniforms(textureProgramInfo, sphereUniforms);
+  twgl.setUniforms(programInfo, sphereUniforms);

  // вызывает gl.drawArrays или gl.drawElements
  twgl.drawBufferInfo(gl, sphereBufferInfo);

  // ------ Рисуем плоскость --------

  // Настраиваем все необходимые атрибуты.
  gl.bindVertexArray(planeVAO);

  // Устанавливаем uniforms, которые мы только что вычислили
-  twgl.setUniforms(textureProgramInfo, planeUniforms);
+  twgl.setUniforms(programInfo, planeUniforms);

  // вызывает gl.drawArrays или gl.drawElements
  twgl.drawBufferInfo(gl, planeBufferInfo);
}
</code></pre>
<p>Теперь, когда мы собираемся использовать одни и те же массивы вершин с несколькими
программами шейдеров, нам нужно убедиться, что эти программы используют одни и те же атрибуты.
Это было упомянуто ранее при разговоре о массивах вершин (VAO в коде выше),
но я думаю, что это первый пример на этом сайте, который действительно сталкивается с этой
проблемой. Другими словами, мы собираемся рисовать сферу и плоскость как с
программой шейдера проецируемой текстуры, так и с программой шейдера сплошного цвета.
Программа шейдера проецируемой текстуры имеет 2 атрибута, <code class="notranslate" translate="no">a_position</code> и
<code class="notranslate" translate="no">a_texcoord</code>. Программа шейдера сплошного цвета имеет только один, <code class="notranslate" translate="no">a_position</code>.
Если мы не скажем WebGL, какие местоположения атрибутов использовать, возможно,
он установит <code class="notranslate" translate="no">a_position</code> местоположение = 0 для одного шейдера и местоположение = 1 для другого
(или действительно WebGL может выбрать любое произвольное местоположение). Если это произойдет,
то атрибуты, которые мы настроили в <code class="notranslate" translate="no">sphereVAO</code> и <code class="notranslate" translate="no">planeVAO</code>, не будут соответствовать
обеим программам.</p>
<p>Мы можем решить это 2 способами.</p>
<ol>
<li>В GLSL добавить <code class="notranslate" translate="no">layout(location = 0)</code> перед каждым атрибутом</li>
</ol>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">layout(location = 0) in vec4 a_position;
layout(location = 1) in vec4 a_texcoord;
</code></pre>
<p>Если бы у нас было 150 шейдеров, нам пришлось бы повторять эти местоположения во всех из них
и отслеживать, какие шейдеры используют какие местоположения</p>
<ol start="2">
<li>
<p>вызвать <code class="notranslate" translate="no">gl.bindAttribLocation</code> перед связыванием шейдеров</p>
<p>В данном случае перед тем, как мы вызовем <code class="notranslate" translate="no">gl.linkProgram</code>, мы вызовем <code class="notranslate" translate="no">gl.bindAttribLocation</code>.
(см. <a href="webgl-fundamentals.html">первую статью</a>)</p>
</li>
</ol>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.bindAttribLocation(program, 0, &quot;a_position&quot;);
gl.bindAttribLocation(program, 1, &quot;a_texcoord&quot;);
gl.linkProgram(program);
...
</code></pre>
<p>Мы будем использовать этот второй способ, поскольку он более <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">D.R.Y</a></p>
<p>Библиотека, которую мы используем для компиляции и связывания наших шейдеров, имеет опцию сделать это
для нас. Мы просто передаем ей имена атрибутов и их местоположения, и она
вызовет <code class="notranslate" translate="no">gl.bindAttribLocation</code> для нас</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// настраиваем GLSL программы
+// примечание: Поскольку мы собираемся использовать один и тот же VAO с несколькими
+// программами шейдеров, нам нужно убедиться, что все программы используют
+// одинаковые местоположения атрибутов. Есть 2 способа сделать это.
+// (1) назначить их в GLSL. (2) назначить их, вызвав `gl.bindAttribLocation`
+// перед связыванием. Мы используем метод 2, поскольку он более D.R.Y.
+const programOptions = {
+  attribLocations: {
+    'a_position': 0,
+    'a_normal':   1,
+    'a_texcoord': 2,
+    'a_color':    3,
+  },
+};
-const textureProgramInfo = twgl.createProgramInfo(gl, [vs, fs]);
-const colorProgramInfo = twgl.createProgramInfo(gl, [colorVS, colorFS],);
+const textureProgramInfo = twgl.createProgramInfo(gl, [vs, fs], programOptions);
+const colorProgramInfo = twgl.createProgramInfo(gl, [colorVS, colorFS], programOptions);
</code></pre>
<p>Теперь давайте используем <code class="notranslate" translate="no">drawScene</code>, чтобы нарисовать сцену с точки зрения источника света,
а затем снова с текстурой глубины</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render() {
  twgl.resizeCanvasToDisplaySize(gl.canvas);

  gl.enable(gl.CULL_FACE);
  gl.enable(gl.DEPTH_TEST);

  // сначала рисуем с точки зрения источника света
-  const textureWorldMatrix = m4.lookAt(
+  const lightWorldMatrix = m4.lookAt(
      [settings.posX, settings.posY, settings.posZ],          // позиция
      [settings.targetX, settings.targetY, settings.targetZ], // цель
      [0, 1, 0],                                              // вверх
  );
-  const textureProjectionMatrix = settings.perspective
+  const lightProjectionMatrix = settings.perspective
      ? m4.perspective(
          degToRad(settings.fieldOfView),
          settings.projWidth / settings.projHeight,
          0.5,  // near
          10)   // far
      : m4.orthographic(
          -settings.projWidth / 2,   // left
           settings.projWidth / 2,   // right
          -settings.projHeight / 2,  // bottom
           settings.projHeight / 2,  // top
           0.5,                      // near
           10);                      // far

+  // рисуем в текстуру глубины
+  gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
+  gl.viewport(0, 0, depthTextureSize, depthTextureSize);
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

-  drawScene(textureProjectionMatrix, textureWorldMatrix, m4.identity());
+  drawScene(lightProjectionMatrix, lightWorldMatrix, m4.identity(), colorProgramInfo);

+  // теперь рисуем сцену на canvas, проецируя текстуру глубины в сцену
+  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  let textureMatrix = m4.identity();
  textureMatrix = m4.translate(textureMatrix, 0.5, 0.5, 0.5);
  textureMatrix = m4.scale(textureMatrix, 0.5, 0.5, 0.5);
-  textureMatrix = m4.multiply(textureMatrix, textureProjectionMatrix);
+  textureMatrix = m4.multiply(textureMatrix, lightProjectionMatrix);
  // используем обратную этой мировой матрицы, чтобы сделать
  // матрицу, которая будет преобразовывать другие позиции
  // чтобы быть относительными к этому мировому пространству.
  textureMatrix = m4.multiply(
      textureMatrix,
-      m4.inverse(textureWorldMatrix));
+      m4.inverse(lightWorldMatrix));

  // Вычисляем матрицу проекции
  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const projectionMatrix =
      m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

  // Вычисляем матрицу камеры, используя look at.
  const cameraPosition = [settings.cameraX, settings.cameraY, 7];
  const target = [0, 0, 0];
  const up = [0, 1, 0];
  const cameraMatrix = m4.lookAt(cameraPosition, target, up);

-  drawScene(projectionMatrix, cameraMatrix, textureMatrix); 
+  drawScene(projectionMatrix, cameraMatrix, textureMatrix, textureProgramInfo); 
}
</code></pre>
<p>Обратите внимание, что я переименовал <code class="notranslate" translate="no">textureWorldMatrix</code> в <code class="notranslate" translate="no">lightWorldMatrix</code> и
<code class="notranslate" translate="no">textureProjectionMatrix</code> в <code class="notranslate" translate="no">lightProjectionMatrix</code>. Они действительно
одно и то же, но раньше мы проецировали текстуру через произвольное пространство.
Теперь мы пытаемся проецировать карту теней от источника света. Математика та же,
но казалось уместным переименовать переменные.</p>
<p>Выше мы сначала рендерим сферу и плоскость в текстуру глубины,
используя цветной шейдер, который мы сделали для рисования линий усеченной пирамиды. Этот шейдер
просто рисует сплошной цвет и ничего больше особенного не делает, что все,
что нам нужно при рендеринге в текстуру глубины.</p>
<p>После этого мы рендерим сцену снова на canvas, как мы делали раньше,
проецируя текстуру в сцену.
Когда мы ссылаемся на текстуру глубины в шейдере, только красное
значение действительно, поэтому мы просто повторим его для красного, зеленого и синего.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void main() {
  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
  bool inRange = 
      projectedTexcoord.x &gt;= 0.0 &amp;&amp;
      projectedTexcoord.x &lt;= 1.0 &amp;&amp;
      projectedTexcoord.y &gt;= 0.0 &amp;&amp;
      projectedTexcoord.y &lt;= 1.0;

-  vec4 projectedTexColor = texture2D(u_projectedTexture, projectedTexcoord.xy);
+  // канал 'r' имеет значения глубины
+  vec4 projectedTexColor = vec4(texture2D(u_projectedTexture, projectedTexcoord.xy).rrr, 1);
  vec4 texColor = texture2D(u_texture, v_texcoord) * u_colorMult;
  float projectedAmount = inRange ? 1.0 : 0.0;
  gl_FragColor = mix(texColor, projectedTexColor, projectedAmount);
}
</code></pre>
<p>Пока мы этим занимаемся, давайте добавим куб в сцену</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">+const cubeBufferInfo = twgl.primitives.createCubeBufferInfo(
+    gl,
+    2,  // размер
+);

...

+const cubeUniforms = {
+  u_colorMult: [0.5, 1, 0.5, 1],  // светло-зеленый
+  u_color: [0, 0, 1, 1],
+  u_texture: checkerboardTexture,
+  u_world: m4.translation(3, 1, 0),
+};

...

function drawScene(projectionMatrix, cameraMatrix, textureMatrix, programInfo) {

    ...

+    // ------ Рисуем куб --------
+
+    // Настраиваем все необходимые атрибуты.
+    gl.bindVertexArray(cubeVAO);
+
+    // Устанавливаем uniforms, которые мы только что вычислили
+    twgl.setUniforms(programInfo, cubeUniforms);
+
+    // вызывает gl.drawArrays или gl.drawElements
+    twgl.drawBufferInfo(gl, cubeBufferInfo);

...
</code></pre>
<p>и давайте настроим настройки. Мы переместим камеру
и расширим поле зрения для проекции текстуры, чтобы покрыть больше сцены</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
-  cameraX: 2.5,
+  cameraX: 6,
  cameraY: 5,
  posX: 2.5,
  posY: 4.8,
  posZ: 4.3,
  targetX: 2.5,
  targetY: 0,
  targetZ: 3.5,
  projWidth: 1,
  projHeight: 1,
  perspective: true,
-  fieldOfView: 45,
+  fieldOfView: 120,
};
</code></pre>
<p>примечание: Я переместил код, который рисует куб линий, показывающий
усеченную пирамиду, за пределы функции <code class="notranslate" translate="no">drawScene</code>.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadows-depth-texture.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadows-depth-texture.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Это точно то же самое, что и верхний пример, за исключением того, что вместо
загрузки изображения мы генерируем текстуру глубины,
рендеря сцену в нее. Если вы хотите проверить, настройте <code class="notranslate" translate="no">cameraX</code>
обратно на 2.5 и <code class="notranslate" translate="no">fieldOfView</code> на 45, и это должно выглядеть так же,
как выше, за исключением того, что наша новая текстура глубины проецируется
вместо загруженного изображения.</p>
<p>Значения глубины идут от 0.0 до 1.0, представляя их позицию
через усеченную пирамиду, поэтому 0.0 (темный) близко к кончику
усеченной пирамиды, а 1.0 (светлый) на дальнем открытом конце.</p>
<p>Итак, все, что осталось сделать, это вместо выбора между нашим проецируемым
цветом текстуры и нашим маппированным цветом текстуры, мы можем использовать глубину из
текстуры глубины, чтобы проверить, является ли Z позиция из текстуры глубины
ближе или дальше от источника света, чем глубина пикселя, который мы
просим нарисовать. Если глубина из текстуры глубины ближе, то что-то
блокировало свет, и этот пиксель в тени.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">void main() {
  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
+  float currentDepth = projectedTexcoord.z;

  bool inRange = 
      projectedTexcoord.x &gt;= 0.0 &amp;&amp;
      projectedTexcoord.x &lt;= 1.0 &amp;&amp;
      projectedTexcoord.y &gt;= 0.0 &amp;&amp;
      projectedTexcoord.y &lt;= 1.0;

-  vec4 projectedTexColor = vec4(texture(u_projectedTexture, projectedTexcoord.xy).rrr, 1);
+  float projectedDepth = texture(u_projectedTexture, projectedTexcoord.xy).r;
+  float shadowLight = (inRange &amp;&amp; projectedDepth &lt;= currentDepth) ? 0.0 : 1.0;  

  vec4 texColor = texture(u_texture, v_texcoord) * u_colorMult;
-  outColor = mix(texColor, projectedTexColor, projectedAmount);
+  outColor = vec4(texColor.rgb * shadowLight, texColor.a);
}
</code></pre>
<p>Выше, если <code class="notranslate" translate="no">projectedDepth</code> меньше, чем <code class="notranslate" translate="no">currentDepth</code>, то
с точки зрения источника света что-то было ближе к
источнику света, поэтому этот пиксель, который мы собираемся нарисовать, в тени.</p>
<p>Если мы запустим это, мы получим тень</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadows-basic.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadows-basic.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Это как-то работает, мы можем видеть тень сферы на
земле, но что с этими странными узорами там, где
не должно быть тени? Эти узоры
называются <em>shadow acne</em>. Они происходят из того факта, что
данные глубины, сохраненные в текстуре глубины, были квантованы как в том,
что это текстура, сетка пикселей, она была спроецирована с
точки зрения источника света, но мы сравниваем ее со значениями с точки зрения камеры. Это означает, что сетка значений в
карте глубины не выровнена с нашей камерой, и
поэтому, когда мы вычисляем <code class="notranslate" translate="no">currentDepth</code>, бывают времена, когда одно значение
будет немного больше или немного меньше, чем <code class="notranslate" translate="no">projectedDepth</code>.</p>
<p>Давайте добавим смещение.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">...

+uniform float u_bias;

void main() {
  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
-  float currentDepth = projectedTexcoord.z;
+  float currentDepth = projectedTexcoord.z + u_bias;

  bool inRange = 
      projectedTexcoord.x &gt;= 0.0 &amp;&amp;
      projectedTexcoord.x &lt;= 1.0 &amp;&amp;
      projectedTexcoord.y &gt;= 0.0 &amp;&amp;
      projectedTexcoord.y &lt;= 1.0;

  float projectedDepth = texture(u_projectedTexture, projectedTexcoord.xy).r;
  float shadowLight = (inRange &amp;&amp; projectedDepth &lt;= currentDepth) ? 0.0 : 1.0;  

  vec4 texColor = texture(u_texture, v_texcoord) * u_colorMult;
  outColor = vec4(texColor.rgb * shadowLight, texColor.a);
}
</code></pre>
<p>И нам нужно установить его</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const settings = {
  cameraX: 2.75,
  cameraY: 5,
  posX: 2.5,
  posY: 4.8,
  posZ: 4.3,
  targetX: 2.5,
  targetY: 0,
  targetZ: 3.5,
  projWidth: 1,
  projHeight: 1,
  perspective: true,
  fieldOfView: 120,
+  bias: -0.006,
};

...

function drawScene(projectionMatrix, cameraMatrix, textureMatrix, programInfo, /**/u_lightWorldPosition) {
  // Создаем матрицу вида из матрицы камеры.
  const viewMatrix = m4.inverse(cameraMatrix);

  gl.useProgram(programInfo.program);

  // устанавливаем uniforms, которые одинаковы для сферы и плоскости
  // примечание: любые значения без соответствующего uniform в шейдере
  // игнорируются.
  twgl.setUniforms(programInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
+    u_bias: settings.bias,
    u_textureMatrix: textureMatrix,
    u_projectedTexture: depthTexture,
  });

  ...
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadows-basic-w-bias.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadows-basic-w-bias.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>сдвиньте значение bias, и вы можете увидеть, как это влияет на то, когда и где
появляются узоры.</p>
<p>Чтобы приблизиться к завершению, давайте фактически добавим расчет прожекторного освещения
из <a href="webgl-3d-lighting-spot.html">статьи о прожекторном освещении</a>.</p>
<p>Сначала давайте вставим нужные части в вершинный шейдер напрямую
из <a href="webgl-3d-lighting-spot.html">той статьи</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
in vec4 a_position;
in vec2 a_texcoord;
+in vec3 a_normal;

+uniform vec3 u_lightWorldPosition;
+uniform vec3 u_viewWorldPosition;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform mat4 u_textureMatrix;

out vec2 v_texcoord;
out vec4 v_projectedTexcoord;
+out vec3 v_normal;

+out vec3 v_surfaceToLight;
+out vec3 v_surfaceToView;

void main() {
  // Умножаем позицию на матрицу.
  vec4 worldPosition = u_world * a_position;

  gl_Position = u_projection * u_view * worldPosition;

  // Передаем координату текстуры в фрагментный шейдер.
  v_texcoord = a_texcoord;

  v_projectedTexcoord = u_textureMatrix * worldPosition;

+  // ориентируем нормали и передаем в фрагментный шейдер
+  v_normal = mat3(u_world) * a_normal;
+
+  // вычисляем мировую позицию поверхности
+  vec3 surfaceWorldPosition = (u_world * a_position).xyz;
+
+  // вычисляем вектор поверхности к источнику света
+  // и передаем его в фрагментный шейдер
+  v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
+
+  // вычисляем вектор поверхности к виду/камере
+  // и передаем его в фрагментный шейдер
+  v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
}
</code></pre>
<p>Затем фрагментный шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

// Передается из вершинного шейдера.
in vec2 v_texcoord;
in vec4 v_projectedTexcoord;
+in vec3 v_normal;
+in vec3 v_surfaceToLight;
+in vec3 v_surfaceToView;

uniform vec4 u_colorMult;
uniform sampler2D u_texture;
uniform sampler2D u_projectedTexture;
uniform float u_bias;
+uniform float u_shininess;
+uniform vec3 u_lightDirection;
+uniform float u_innerLimit;          // в пространстве скалярного произведения
+uniform float u_outerLimit;          // в пространстве скалярного произведения

out vec4 outColor;

void main() {
+  // поскольку v_normal является varying, он интерполируется
+  // поэтому он не будет единичным вектором. Нормализация
+  // сделает его снова единичным вектором
+  vec3 normal = normalize(v_normal);
+
+  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
+  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
+  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);
+
+  float dotFromDirection = dot(surfaceToLightDirection,
+                               -u_lightDirection);
+  float limitRange = u_innerLimit - u_outerLimit;
+  float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.0, 1.0);
+  float light = inLight * dot(normal, surfaceToLightDirection);
+  float specular = inLight * pow(dot(normal, halfVector), u_shininess);

  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
  float currentDepth = projectedTexcoord.z + u_bias;

  bool inRange =
      projectedTexcoord.x &gt;= 0.0 &amp;&amp;
      projectedTexcoord.x &lt;= 1.0 &amp;&amp;
      projectedTexcoord.y &gt;= 0.0 &amp;&amp;
      projectedTexcoord.y &lt;= 1.0;

  // канал 'r' имеет значения глубины
  float projectedDepth = texture(u_projectedTexture, projectedTexcoord.xy).r;
  float shadowLight = (inRange &amp;&amp; projectedDepth &lt;= currentDepth) ? 0.0 : 1.0;

  vec4 texColor = texture(u_texture, v_texcoord) * u_colorMult;
-  outColor = vec4(texColor.rgb * shadowLight, texColor.a);
+  outColor = vec4(
+      texColor.rgb * light * shadowLight +
+      specular * shadowLight,
+      texColor.a);
}
</code></pre>
<p>Обратите внимание, что мы просто используем <code class="notranslate" translate="no">shadowLight</code> для корректировки эффекта <code class="notranslate" translate="no">light</code> и
<code class="notranslate" translate="no">specular</code>. Если объект в тени, то света нет.</p>
<p>Нам просто нужно установить uniforms</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">-function drawScene(projectionMatrix, cameraMatrix, textureMatrix, programInfo) {
+function drawScene(
+    projectionMatrix,
+    cameraMatrix,
+    textureMatrix,
+    lightWorldMatrix,
+    programInfo) {
  // Создаем матрицу вида из матрицы камеры.
  const viewMatrix = m4.inverse(cameraMatrix);

  gl.useProgram(programInfo.program);

  // устанавливаем uniforms, которые одинаковы для сферы и плоскости
  // примечание: любые значения без соответствующего uniform в шейдере
  // игнорируются.
  twgl.setUniforms(programInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
    u_bias: settings.bias,
    u_textureMatrix: textureMatrix,
    u_projectedTexture: depthTexture,
+    u_shininess: 150,
+    u_innerLimit: Math.cos(degToRad(settings.fieldOfView / 2 - 10)),
+    u_outerLimit: Math.cos(degToRad(settings.fieldOfView / 2)),
+    u_lightDirection: lightWorldMatrix.slice(8, 11).map(v =&gt; -v),
+    u_lightWorldPosition: lightWorldMatrix.slice(12, 15),
+    u_viewWorldPosition: cameraMatrix.slice(12, 15),
  });

...

function render() {
  ...

-  drawScene(lightProjectionMatrix, lightWorldMatrix, m4.identity(), colorProgramInfo);
+  drawScene(
+      lightProjectionMatrix,
+      lightWorldMatrix,
+      m4.identity(),
+      lightWorldMatrix,
+      colorProgramInfo);

  ...

-  drawScene(projectionMatrix, cameraMatrix, textureMatrix, textureProgramInfo);
+  drawScene(
+      projectionMatrix,
+      cameraMatrix,
+      textureMatrix,
+      lightWorldMatrix,
+      textureProgramInfo);

  ...
}
</code></pre>
<p>Чтобы пройтись по нескольким из этих настроек uniform. Напомним из <a href="webgl-3d-lighting-spot.html">статьи о прожекторном освещении</a>,
что настройки innerLimit и outerLimit находятся в пространстве скалярного произведения (пространство косинуса) и что
нам нужна только половина поля зрения, поскольку они простираются вокруг направления света.
Также напомним из <a href="webgl-3d-camera.html">статьи о камере</a>, что 3-я строка матрицы 4x4
является осью Z, поэтому извлечение первых 3 значений 3-й строки из <code class="notranslate" translate="no">lightWorldMatrix</code>
дает нам направление -Z света. Мы хотим положительное направление, поэтому переворачиваем его.
Аналогично та же статья говорит нам, что 4-я строка - это мировая позиция, поэтому мы можем получить
lightWorldPosition и viewWorldPosition (также известную как мировая позиция камеры),
извлекая их из их соответствующих матриц. Конечно, мы могли бы также
получить их, раскрывая больше настроек или передавая больше переменных.</p>
<p>Давайте также очистим фон до черного и установим линии усеченной пирамиды в белый</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render() {

  ...

  // теперь рисуем сцену на canvas, проецируя текстуру глубины в сцену
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  ...

  // ------ Рисуем усеченную пирамиду ------
  {

    ...

          // Устанавливаем uniforms, которые мы только что вычислили
    twgl.setUniforms(colorProgramInfo, {
-      u_color: [0, 0, 0, 1],
+      u_color: [1, 1, 1, 1],
      u_view: viewMatrix,
      u_projection: projectionMatrix,
      u_world: mat,
    });
</code></pre>
<p>И теперь у нас есть прожекторное освещение с тенями.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadows-w-spot-light.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadows-w-spot-light.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Для направленного света мы скопируем код шейдера из
<a href="webgl-3d-lighting-directional.html">статьи о направленном освещении</a>
и изменим нашу проекцию с перспективной на ортографическую.</p>
<p>Сначала вершинный шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
in vec4 a_position;
in vec2 a_texcoord;
+in vec3 a_normal;

-uniform vec3 u_lightWorldPosition;
-uniform vec3 u_viewWorldPosition;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform mat4 u_textureMatrix;

out vec2 v_texcoord;
out vec4 v_projectedTexcoord;
out vec3 v_normal;

-out vec3 v_surfaceToLight;
-out vec3 v_surfaceToView;

void main() {
  // Умножаем позицию на матрицу.
  vec4 worldPosition = u_world * a_position;

  gl_Position = u_projection * u_view * worldPosition;

  // Передаем координату текстуры в фрагментный шейдер.
  v_texcoord = a_texcoord;

  v_projectedTexcoord = u_textureMatrix * worldPosition;

  // ориентируем нормали и передаем в фрагментный шейдер
  v_normal = mat3(u_world) * a_normal;

-  // вычисляем мировую позицию поверхности
-  vec3 surfaceWorldPosition = (u_world * a_position).xyz;
-
-  // вычисляем вектор поверхности к источнику света
-  // и передаем его в фрагментный шейдер
-  v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
-
-  // вычисляем вектор поверхности к виду/камере
-  // и передаем его в фрагментный шейдер
-  v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
}
</code></pre>
<p>Затем фрагментный шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

// Передается из вершинного шейдера.
in vec2 v_texcoord;
in vec4 v_projectedTexcoord;
in vec3 v_normal;
-in vec3 v_surfaceToLight;
-in vec3 v_surfaceToView;

uniform vec4 u_colorMult;
uniform sampler2D u_texture;
uniform sampler2D u_projectedTexture;
uniform float u_bias;
-uniform float u_shininess;
-uniform vec3 u_lightDirection;
-uniform float u_innerLimit;          // в пространстве скалярного произведения
-uniform float u_outerLimit;          // в пространстве скалярного произведения
+uniform vec3 u_reverseLightDirection;

out vec4 outColor;

void main() {
  // поскольку v_normal является varying, он интерполируется
  // поэтому он не будет единичным вектором. Нормализация
  // сделает его снова единичным вектором
  vec3 normal = normalize(v_normal);

+  float light = dot(normal, u_reverseLightDirection);

-  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
-  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
-  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);
-
-  float dotFromDirection = dot(surfaceToLightDirection,
-                               -u_lightDirection);
-  float limitRange = u_innerLimit - u_outerLimit;
-  float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.0, 1.0);
-  float light = inLight * dot(normal, surfaceToLightDirection);
-  float specular = inLight * pow(dot(normal, halfVector), u_shininess);

  vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
  float currentDepth = projectedTexcoord.z + u_bias;

  bool inRange =
      projectedTexcoord.x &gt;= 0.0 &amp;&amp;
      projectedTexcoord.x &lt;= 1.0 &amp;&amp;
      projectedTexcoord.y &gt;= 0.0 &amp;&amp;
      projectedTexcoord.y &lt;= 1.0;

  // канал 'r' имеет значения глубины
  float projectedDepth = texture(u_projectedTexture, projectedTexcoord.xy).r;
  float shadowLight = (inRange &amp;&amp; projectedDepth &lt;= currentDepth) ? 0.0 : 1.0;

  vec4 texColor = texture(u_texture, v_texcoord) * u_colorMult;
  outColor = vec4(
-      texColor.rgb * light * shadowLight +
-      specular * shadowLight,
+      texColor.rgb * light * shadowLight,
      texColor.a);
}
</code></pre>
<p>и uniforms</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // устанавливаем uniforms, которые одинаковы для сферы и плоскости
  // примечание: любые значения без соответствующего uniform в шейдере
  // игнорируются.
  twgl.setUniforms(programInfo, {
    u_view: viewMatrix,
    u_projection: projectionMatrix,
    u_bias: settings.bias,
    u_textureMatrix: textureMatrix,
    u_projectedTexture: depthTexture,
-    u_shininess: 150,
-    u_innerLimit: Math.cos(degToRad(settings.fieldOfView / 2 - 10)),
-    u_outerLimit: Math.cos(degToRad(settings.fieldOfView / 2)),
-    u_lightDirection: lightWorldMatrix.slice(8, 11).map(v =&gt; -v),
-    u_lightWorldPosition: lightWorldMatrix.slice(12, 15),
-    u_viewWorldPosition: cameraMatrix.slice(12, 15),
+    u_reverseLightDirection: lightWorldMatrix.slice(8, 11),
  });
</code></pre>
<p>Я настроил камеру, чтобы видеть больше сцены.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-shadows-w-directional-light.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-shadows-w-directional-light.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Это указывает на что-то, что должно быть очевидно из кода выше, но наша
карта теней только такая большая, поэтому даже though вычисления направленного света
имеют только направление, нет позиции для самого света, мы все еще
должны выбрать позицию, чтобы решить область для вычисления и применения
карты теней.</p>
<p>Эта статья становится длинной, и есть еще много вещей для покрытия, связанных
с тенями, поэтому мы оставим остальное для <a href="webgl-shadows-continued.html">следующей статьи</a>.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-shadows.html" >English</a>
    <option value="/webgl/lessons/de/webgl-shadows.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-shadows.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shadows.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-shadows.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-shadows.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shadows.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-getting-webgl2.html">Как использовать WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как это работает</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 Диаграмма состояния</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl2-whats-new.html">Что нового в WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2.html">Переход с WebGL1 на WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2-fundamentals.html">Отличия от WebGLFundamentals.org до WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продвинутая обработка изображений</a></li>
        </ul>
  <li>2D трансформации, повороты, масштабирование и матричные операции</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D Трансляция</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D Вращение</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D Масштабирование</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D Матрицы</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">Ортографическая 3D</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">3D Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">3D - Камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-naming.html">3D - Именование матриц</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
        </ul>
  <li>Организация и рефакторинг</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">Меньше кода, больше удовольствия</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">Рисование множественных объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">Графы сцен</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">3D Геометрия - Токарная обработка</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Загрузка .obj файлов</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Загрузка .obj с .mtl файлами</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">Использование 2 или более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">Перспективно-корректное наложение текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Планарное и перспективное проекционное отображение</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
        </ul>
  <li>Тени</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Тени</a></li>
        </ul>
  <li>Техники</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">2D - Стек Матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Спрайты</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Кубические карты</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Карты окружения</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Скайбоксы</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Скининг</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Выбор объектов (клик по объектам)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">Текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">Текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">Текст - Использование текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">Текст - Использование текстуры глифов</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Самые маленькие программы</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Рисование без данных</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Вытягивание вершин</a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Индексированные вершины (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Инстансинг (Instanced Drawing)</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">Настройка и установка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Точки, линии и треугольники</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Множественные виды, множественные canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL2 и альфа-канал</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">2D против 3D библиотек</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">Анти-паттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL2 Матрицы против математических матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Проблемы точности</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Скриншот канваса</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Как не очищать канвас</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Получение ввода с клавиатуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Использование WebGL2 как фона в HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Справочник</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Атрибуты</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Текстурные юниты</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">Ссылки</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API документация</a></li>
  <li><a href="https://twgljs.org">TWGL, легковесная библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Есть предложения или замечания? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Создайте issue на GitHub</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Тени';
            var disqus_title = 'WebGL2 Тени';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Спасибо <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>за <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} вкладов</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



