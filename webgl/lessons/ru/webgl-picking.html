<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-picking.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Как выбирать объекты в WebGL">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-picking_ru.jpg">

<meta property="og:title" content="WebGL2 Выбор объектов">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-picking_ru.jpg">
<meta property="og:description" content="Как выбирать объекты в WebGL">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-picking.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Выбор объектов">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-picking.html">
<meta name="twitter:description" content="Как выбирать объекты в WebGL">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-picking_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-picking.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-picking_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-picking.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-picking.html",
      "inLanguage":"ru",
      "name":"WebGL2 Выбор объектов",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-picking.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Выбор объектов</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-picking.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-picking.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-picking.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-picking.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-picking.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-picking.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-picking.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-picking.html" >English</a>
    <option value="/webgl/lessons/de/webgl-picking.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-picking.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-picking.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-picking.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-picking.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-picking.html" >简体中文</a>
</select>


    <a href="#toc">Содержание</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Выбор объектов</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Эта статья о том, как использовать WebGL для того, чтобы пользователь мог выбирать или выделять
объекты.</p>
<p>Если вы читали другие статьи на этом сайте, вы, надеюсь, поняли,
что WebGL сам по себе - это просто библиотека растеризации. Он рисует треугольники,
линии и точки на canvas, поэтому у него нет концепции “объектов для
выбора”. Он просто выводит пиксели через шейдеры, которые вы предоставляете. Это означает,
что любая концепция “выбора” чего-либо должна исходить из вашего кода. Вам нужно
определить, что это за вещи, которые вы позволяете пользователю выбирать.
Это означает, что хотя эта статья может охватывать общие концепции, вам нужно будет
самостоятельно решить, как перевести то, что вы видите здесь, в применимые
концепции в вашем собственном приложении.</p>
<h2 id="клик-по-объекту">Клик по объекту</h2>
<p>Один из самых простых способов выяснить, на какую вещь кликнул пользователь, это
придумать числовой id для каждого объекта, затем мы можем нарисовать
все объекты, используя их id как цвет, без освещения
и без текстур. Это даст нам изображение силуэтов
каждого объекта. Буфер глубины будет обрабатывать сортировку за нас.
Затем мы можем прочитать цвет пикселя под
мышью, который даст нам id объекта, который был отрендерен там.</p>
<p>Для реализации этой техники нам нужно будет объединить несколько предыдущих
статей. Первая - это статья о <a href="webgl-drawing-multiple-things.html">рисовании множественных объектов</a>,
которую мы будем использовать, потому что, учитывая, что она рисует множество вещей, мы можем попытаться
выбрать их.</p>
<p>Помимо этого, мы обычно хотим рендерить эти id вне экрана,
<a href="webgl-render-to-texture.html">рендеря в текстуру</a>, поэтому мы
также добавим этот код.</p>
<p>Итак, давайте начнем с последнего примера из
<a href="webgl-drawing-multiple-things.html">статьи о рисовании множественных вещей</a>,
которая рисует 200 объектов.</p>
<p>К нему давайте добавим framebuffer с присоединенной текстурой и буфером глубины из
последнего примера в <a href="webgl-render-to-texture.html">статье о рендеринге в текстуру</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Создаем текстуру для рендеринга
const targetTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, targetTexture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// создаем буфер глубины
const depthBuffer = gl.createRenderbuffer();
gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);

function setFramebufferAttachmentSizes(width, height) {
  gl.bindTexture(gl.TEXTURE_2D, targetTexture);
  // определяем размер и формат уровня 0
  const level = 0;
  const internalFormat = gl.RGBA;
  const border = 0;
  const format = gl.RGBA;
  const type = gl.UNSIGNED_BYTE;
  const data = null;
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border,
                format, type, data);

  gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
}

// Создаем и привязываем framebuffer
const fb = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

// присоединяем текстуру как первое цветовое вложение
const attachmentPoint = gl.COLOR_ATTACHMENT0;
const level = 0;
gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);

// делаем буфер глубины того же размера, что и targetTexture
gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
</code></pre>
<p>Мы поместили код для установки размеров текстуры и
буфера глубины в функцию, чтобы мы могли
вызывать ее для изменения их размера в соответствии с размером
canvas.</p>
<p>В нашем коде рендеринга, если canvas изменяет размер,
мы скорректируем текстуру и renderbuffer, чтобы они соответствовали.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawScene(time) {
  time *= 0.0005;

  if (webglUtils.resizeCanvasToDisplaySize(gl.canvas)) {
    // canvas был изменен, делаем вложения framebuffer соответствующими
    setFramebufferAttachmentSizes(gl.canvas.width, gl.canvas.height);
  }

...
</code></pre>
<p>Далее нам нужен второй шейдер. Шейдер в
примере рендерит, используя цвета вершин, но нам нужен
тот, который мы можем установить в сплошной цвет для рендеринга с id.
Итак, сначала вот наш второй шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const pickingVS = `#version 300 es
  in vec4 a_position;
  
  uniform mat4 u_matrix;
  
  void main() {
    // Умножаем позицию на матрицу.
    gl_Position = u_matrix * a_position;
  }
`;

const pickingFS = `#version 300 es
  precision highp float;
  
  uniform vec4 u_id;

  out vec4 outColor;
  
  void main() {
     outColor = u_id;
  }
`;
</code></pre>
<p>И нам нужно скомпилировать, связать и найти местоположения,
используя наши <a href="webgl-less-code-more-fun.html">помощники</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// настройка GLSL программы
// примечание: нам нужны позиции атрибутов, чтобы соответствовать между программами
// чтобы нам нужен был только один vertex array на форму
const options = {
  attribLocations: {
    a_position: 0,
    a_color: 1,
  },
};
const programInfo = twgl.createProgramInfo(gl, [vs, fs], options);
const pickingProgramInfo = twgl.createProgramInfo(gl, [pickingVS, pickingFS], options);
</code></pre>
<p>Одно отличие выше от большинства примеров на этом сайте, это один
из немногих случаев, когда нам нужно было рисовать те же данные с 2 разными
шейдерами. Из-за этого нам нужны местоположения атрибутов, чтобы соответствовать
между шейдерами. Мы можем сделать это 2 способами. Один способ - установить их
вручную в GLSL</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">layout (location = 0) in vec4 a_position;
layout (location = 1) in vec4 a_color;
</code></pre>
<p>Другой - вызвать <code class="notranslate" translate="no">gl.bindAttribLocation</code> <strong>до</strong> связывания
шейдерной программы</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.bindAttribLocation(someProgram, 0, 'a_position');
gl.bindAttribLocation(someProgram, 1, 'a_color');
gl.linkProgram(someProgram);
</code></pre>
<p>Этот последний стиль необычен, но он более
<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">D.R.Y.</a>.
Наша библиотека помощников вызовет <code class="notranslate" translate="no">gl.bindAttribLocation</code> для нас,
если мы передадим имена атрибутов и местоположение, которое мы хотим,
что и происходит выше.</p>
<p>Это означает, что мы можем гарантировать, что атрибут <code class="notranslate" translate="no">a_position</code> использует
местоположение 0 в обеих программах, поэтому мы можем использовать тот же vertex array
с обеими программами.</p>
<p>Далее нам нужно иметь возможность рендерить все объекты
дважды. Один раз с любым шейдером, который мы назначили
им, и снова с шейдером, который мы только что написали,
поэтому давайте извлечем код, который в настоящее время рендерит
все объекты в функцию.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function drawObjects(objectsToDraw, overrideProgramInfo) {
  objectsToDraw.forEach(function(object) {
    const programInfo = overrideProgramInfo || object.programInfo;
    const bufferInfo = object.bufferInfo;
    const vertexArray = object.vertexArray;

    gl.useProgram(programInfo.program);

    // Настраиваем все нужные атрибуты.
    gl.bindVertexArray(vertexArray);

    // Устанавливаем uniforms.
    twgl.setUniforms(programInfo, object.uniforms);

    // Рисуем (вызывает gl.drawArrays или gl.drawElements)
    twgl.drawBufferInfo(gl, object.bufferInfo);
  });
}
</code></pre>
<p><code class="notranslate" translate="no">drawObjects</code> принимает опциональный <code class="notranslate" translate="no">overrideProgramInfo</code>,
который мы можем передать, чтобы использовать наш picking шейдер вместо
назначенного объекту шейдера.</p>
<p>Давайте вызовем его один раз, чтобы нарисовать в текстуру с
id, и снова, чтобы нарисовать сцену на canvas.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Рисуем сцену.
function drawScene(time) {
  time *= 0.0005;

  ...

  // Вычисляем матрицы для каждого объекта.
  objects.forEach(function(object) {
    object.uniforms.u_matrix = computeMatrix(
        viewProjectionMatrix,
        object.translation,
        object.xRotationSpeed * time,
        object.yRotationSpeed * time);
  });

+  // ------ Рисуем объекты в текстуру --------
+
+  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
+  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
+
+  gl.enable(gl.CULL_FACE);
+  gl.enable(gl.DEPTH_TEST);
+
+  // Очищаем canvas И буфер глубины.
+  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
+
+  drawObjects(objectsToDraw, pickingProgramInfo);
+
+  // ------ Рисуем объекты на canvas

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  drawObjects(objectsToDraw);

  requestAnimationFrame(drawScene);
}
</code></pre>
<p>И с этим мы должны иметь возможность двигать мышью по
сцене, и объект под мышью будет мигать</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-picking-w-gpu.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-picking-w-gpu.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Одна оптимизация, которую мы можем сделать, мы рендерим
id в текстуру того же размера,
что и canvas. Это концептуально самая простая
вещь для выполнения.</p>
<p>Но мы могли бы вместо этого просто рендерить пиксель
под мышью. Для этого мы используем усеченную пирамиду,
математика которой будет покрывать только пространство для этого
1 пикселя.</p>
<p>До сих пор для 3D мы использовали функцию под названием
<code class="notranslate" translate="no">perspective</code>, которая принимает в качестве входных данных поле зрения, соотношение сторон и
ближнее и дальнее значения для z-плоскостей и создает
матрицу перспективной проекции, которая преобразует из
усеченной пирамиды, определенной этими значениями, в clip space.</p>
<p>Большинство 3D математических библиотек имеют другую функцию под названием
<code class="notranslate" translate="no">frustum</code>, которая принимает 6 значений, левое, правое, верхнее,
и нижнее значения для ближней z-плоскости, а затем
z-ближнее и z-дальнее значения для z-плоскостей и генерирует
матрицу перспективы, определенную этими значениями.</p>
<p>Используя это, мы можем сгенерировать матрицу перспективы для
одного пикселя под мышью</p>
<p>Сначала мы вычисляем края и размер того, чем была бы наша ближняя плоскость,
если бы мы использовали функцию <code class="notranslate" translate="no">perspective</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// вычисляем прямоугольник, который покрывает ближняя плоскость нашей усеченной пирамиды
const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
const top = Math.tan(fieldOfViewRadians * 0.5) * near;
const bottom = -top;
const left = aspect * bottom;
const right = aspect * top;
const width = Math.abs(right - left);
const height = Math.abs(top - bottom);
</code></pre>
<p>Итак, <code class="notranslate" translate="no">left</code>, <code class="notranslate" translate="no">right</code>, <code class="notranslate" translate="no">width</code> и <code class="notranslate" translate="no">height</code> - это
размер и позиция ближней плоскости. Теперь на этой
плоскости мы можем вычислить размер и позицию
одного пикселя под мышью и передать это в
функцию <code class="notranslate" translate="no">frustum</code> для генерации матрицы проекции,
которая покрывает только этот 1 пиксель</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// вычисляем часть ближней плоскости, которая покрывает 1 пиксель
// под мышью.
const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;

const subLeft = left + pixelX * width / gl.canvas.width;
const subBottom = bottom + pixelY * height / gl.canvas.height;
const subWidth = width / gl.canvas.width;
const subHeight = height / gl.canvas.height;

// делаем усеченную пирамиду для этого 1 пикселя
const projectionMatrix = m4.frustum(
    subLeft,
    subLeft + subWidth,
    subBottom,
    subBottom + subHeight,
    near,
    far);
</code></pre>
<p>Для использования этого нам нужно внести некоторые изменения. Как сейчас наш шейдер
просто принимает <code class="notranslate" translate="no">u_matrix</code>, что означает, что для рисования с другой
матрицей проекции нам нужно будет пересчитывать матрицы для каждого объекта
дважды каждый кадр, один раз с нашей нормальной матрицей проекции для рисования
на canvas и снова для этой матрицы проекции 1 пикселя.</p>
<p>Мы можем убрать эту ответственность из JavaScript, переместив это
умножение в вершинные шейдеры.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">const vs = `#version 300 es

in vec4 a_position;
in vec4 a_color;

-uniform mat4 u_matrix;
+uniform mat4 u_viewProjection;
+uniform mat4 u_world;

out vec4 v_color;

void main() {
  // Умножаем позицию на матрицу.
-  gl_Position = u_matrix * a_position;
+  gl_Position = u_viewProjection * u_world * a_position;

  // Передаем цвет в фрагментный шейдер.
  v_color = a_color;
}
`;

...

const pickingVS = `#version 300 es
  in vec4 a_position;
  
-  uniform mat4 u_matrix;
+  uniform mat4 u_viewProjection;
+  uniform mat4 u_world;
  
  void main() {
    // Умножаем позицию на матрицу.
-   gl_Position = u_matrix * a_position;
+    gl_Position = u_viewProjection * u_world * a_position;
  }
`;
</code></pre>
<p>Затем мы можем сделать наш JavaScript <code class="notranslate" translate="no">viewProjectionMatrix</code> общим
среди всех объектов.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const objectsToDraw = [];
const objects = [];
const viewProjectionMatrix = m4.identity();

// Создаем информацию для каждого объекта для каждого объекта.
const baseHue = rand(0, 360);
const numObjects = 200;
for (let ii = 0; ii &lt; numObjects; ++ii) {
  const id = ii + 1;

  // выбираем форму
  const shape = shapes[rand(shapes.length) | 0];

  const object = {
    uniforms: {
      u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
      u_world: m4.identity(),
      u_viewProjection: viewProjectionMatrix,
      u_id: [
        ((id &gt;&gt;  0) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt;  8) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 16) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 24) &amp; 0xFF) / 0xFF,
      ],
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
  objects.push(object);

  // Добавляем его в список вещей для рисования.
  objectsToDraw.push({
    programInfo: programInfo,
    bufferInfo: shape.bufferInfo,
    vertexArray: shape.vertexArray,
    uniforms: object.uniforms,
  });
}
</code></pre>
<p>И где мы вычисляем матрицы для каждого объекта, нам больше не нужно
включать матрицу проекции вида</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function computeMatrix(translation, xRotation, yRotation) {
  let matrix = m4.translation(
      translation[0],
      translation[1],
      translation[2]);
  matrix = m4.xRotate(matrix, xRotation);
  return m4.yRotate(matrix, yRotation);
}
</code></pre>
<p>gl.bindFramebuffer(gl.FRAMEBUFFER, null);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);</p>
<p>drawObjects(objectsToDraw);</p>
<p>requestAnimationFrame(drawScene);
}</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">
Нашему picking шейдеру нужен `u_id`, установленный в id, поэтому давайте
добавим это к нашим данным uniform, где мы настраиваем наши объекты.

```js
// Создаем информацию для каждого объекта для каждого объекта.
const baseHue = rand(0, 360);
const numObjects = 200;
for (let ii = 0; ii &lt; numObjects; ++ii) {
  const id = ii + 1;

  // выбираем форму
  const shape = shapes[rand(shapes.length) | 0];

  const object = {
    uniforms: {
      u_colorMult: chroma.hsv(eMod(baseHue + rand(0, 120), 360), rand(0.5, 1), rand(0.5, 1)).gl(),
      u_matrix: m4.identity(),
      u_id: [
        ((id &gt;&gt;  0) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt;  8) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 16) &amp; 0xFF) / 0xFF,
        ((id &gt;&gt; 24) &amp; 0xFF) / 0xFF,
      ],
    },
    translation: [rand(-100, 100), rand(-100, 100), rand(-150, -50)],
    xRotationSpeed: rand(0.8, 1.2),
    yRotationSpeed: rand(0.8, 1.2),
  };
  objects.push(object);

  // Добавляем его в список вещей для рисования.
  objectsToDraw.push({
    programInfo: programInfo,
    bufferInfo: shape.bufferInfo,
    vertexArray: shape.vertexArray,
    uniforms: object.uniforms,
  });
}
</code></pre>
<p>Это будет работать, потому что наша <a href="webgl-less-code-more-fun.html">библиотека помощников</a>
обрабатывает применение uniforms для нас.</p>
<p>Нам пришлось разделить id по R, G, B и A. Потому что формат/тип нашей
текстуры - <code class="notranslate" translate="no">gl.RGBA</code>, <code class="notranslate" translate="no">gl.UNSIGNED_BYTE</code>,
мы получаем 8 бит на канал. 8 бит представляют только 256 значений,
но, разделив id по 4 каналам, мы получаем 32 бита всего,
что составляет &gt; 4 миллиарда значений.</p>
<p>Мы добавляем 1 к id, потому что мы будем использовать 0 для обозначения
“ничего под мышью”.</p>
<p>Теперь давайте выделим объект под мышью.</p>
<p>Сначала нам нужен код для получения позиции мыши относительно canvas.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// mouseX и mouseY находятся в CSS display space относительно canvas
let mouseX = -1;
let mouseY = -1;

...

gl.canvas.addEventListener('mousemove', (e) =&gt; {
   const rect = canvas.getBoundingClientRect();
   mouseX = e.clientX - rect.left;
   mouseY = e.clientY - rect.top;
});
</code></pre>
<p>Обратите внимание, что с кодом выше <code class="notranslate" translate="no">mouseX</code> и <code class="notranslate" translate="no">mouseY</code>
находятся в CSS пикселях в display space. Это означает,
что они находятся в пространстве, где отображается canvas,
а не в пространстве того, сколько пикселей в canvas.
Другими словами, если у вас был canvas как этот</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-html">&lt;canvas width=&quot;11&quot; height=&quot;22&quot; style=&quot;width:33px; height:44px;&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>тогда <code class="notranslate" translate="no">mouseX</code> будет идти от 0 до 33 по canvas и
<code class="notranslate" translate="no">mouseY</code> будет идти от 0 до 44 по canvas. Смотрите <a href="webgl-resizing-the-canvas.html">это</a>
для получения дополнительной информации.</p>
<p>Теперь, когда у нас есть позиция мыши, давайте добавим код
для поиска пикселя под мышью</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;
const data = new Uint8Array(4);
gl.readPixels(
    pixelX,            // x
    pixelY,            // y
    1,                 // width
    1,                 // height
    gl.RGBA,           // format
    gl.UNSIGNED_BYTE,  // type
    data);             // typed array to hold result
const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);
</code></pre>
<p>Код выше, который вычисляет <code class="notranslate" translate="no">pixelX</code> и <code class="notranslate" translate="no">pixelY</code>, преобразует
из <code class="notranslate" translate="no">mouseX</code> и <code class="notranslate" translate="no">mouseY</code> в display space в пиксели в пространстве canvas.
Другими словами, учитывая пример выше, где <code class="notranslate" translate="no">mouseX</code> шел от
0 до 33 и <code class="notranslate" translate="no">mouseY</code> шел от 0 до 44. <code class="notranslate" translate="no">pixelX</code> будет идти от 0 до 11
и <code class="notranslate" translate="no">pixelY</code> будет идти от 0 до 22.</p>
<p>В нашем фактическом коде мы используем нашу утилитную функцию <code class="notranslate" translate="no">resizeCanvasToDisplaySize</code>
и мы делаем нашу текстуру того же размера, что и canvas, поэтому display
размер и размер canvas совпадают, но, по крайней мере, мы готовы к случаю,
когда они не совпадают.</p>
<p>Теперь, когда у нас есть id, чтобы фактически выделить выбранный объект,
давайте изменим цвет, который мы используем для его рендеринга на canvas.
Шейдер, который мы использовали, имеет uniform <code class="notranslate" translate="no">u_colorMult</code>,
который мы можем использовать, поэтому если объект под мышью, мы найдем его,
сохраним его значение <code class="notranslate" translate="no">u_colorMult</code>, заменим его цветом выделения,
и восстановим его.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// mouseX и mouseY находятся в CSS display space относительно canvas
let mouseX = -1;
let mouseY = -1;
let oldPickNdx = -1;
let oldPickColor;
let frameCount = 0;

// Рисуем сцену.
function drawScene(time) {
  time *= 0.0005;
  ++frameCount;

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
</code></pre>
<p>Перед рендерингом id вне экрана мы устанавливаем матрицу проекции вида,
используя нашу матрицу проекции для 1 пикселя, а при рисовании на canvas
используем исходную матрицу проекции.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Вычисляем матрицу камеры с помощью lookAt.
const cameraPosition = [0, 0, 100];
const target = [0, 0, 0];
const up = [0, 1, 0];
const cameraMatrix = m4.lookAt(cameraPosition, target, up);

// Создаём матрицу вида из матрицы камеры.
const viewMatrix = m4.inverse(cameraMatrix);

// Вычисляем матрицы для каждого объекта.
objects.forEach(function(object) {
  object.uniforms.u_world = computeMatrix(
      object.translation,
      object.xRotationSpeed * time,
      object.yRotationSpeed * time);
});

// ------ Рисуем объекты в текстуру --------

// Определяем, какой пиксель под мышью, и настраиваем
// усечённую пирамиду для рендера только этого пикселя

{
  // вычисляем прямоугольник, который покрывает ближнюю плоскость нашей усечённой пирамиды
  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const top = Math.tan(fieldOfViewRadians * 0.5) * near;
  const bottom = -top;
  const left = aspect * bottom;
  const right = aspect * top;
  const width = Math.abs(right - left);
  const height = Math.abs(top - bottom);

  // вычисляем часть ближней плоскости, которая покрывает 1 пиксель под мышью
  const pixelX = mouseX * gl.canvas.width / gl.canvas.clientWidth;
  const pixelY = gl.canvas.height - mouseY * gl.canvas.height / gl.canvas.clientHeight - 1;

  const subLeft = left + pixelX * width / gl.canvas.width;
  const subBottom = bottom + pixelY * height / gl.canvas.height;
  const subWidth = width / gl.canvas.width;
  const subHeight = height / gl.canvas.height;

  // создаём усечённую пирамиду для этого 1 пикселя
  const projectionMatrix = m4.frustum(
      subLeft,
      subLeft + subWidth,
      subBottom,
      subBottom + subHeight,
      near,
      far);
  m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
}

gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
gl.viewport(0, 0, 1, 1);

gl.enable(gl.CULL_FACE);
gl.enable(gl.DEPTH_TEST);

gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

drawObjects(objectsToDraw, pickingProgramInfo);

// читаем 1 пиксель
const data = new Uint8Array(4);
gl.readPixels(
    0,                 // x
    0,                 // y
    1,                 // width
    1,                 // height
    gl.RGBA,           // format
    gl.UNSIGNED_BYTE,  // type
    data);             // typed array to hold result
const id = data[0] + (data[1] &lt;&lt; 8) + (data[2] &lt;&lt; 16) + (data[3] &lt;&lt; 24);

// восстанавливаем цвет объекта
if (oldPickNdx &gt;= 0) {
  const object = objects[oldPickNdx];
  object.uniforms.u_colorMult = oldPickColor;
  oldPickNdx = -1;
}

// выделяем объект под мышью
if (id &gt; 0) {
  const pickNdx = id - 1;
  oldPickNdx = pickNdx;
  const object = objects[pickNdx];
  oldPickColor = object.uniforms.u_colorMult;
  object.uniforms.u_colorMult = (frameCount &amp; 0x8) ? [1, 0, 0, 1] : [1, 1, 0, 1];
}

// ------ Рисуем объекты на canvas

{
  // Вычисляем матрицу проекции
  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const projectionMatrix =
      m4.perspective(fieldOfViewRadians, aspect, near, far);

  m4.multiply(projectionMatrix, viewMatrix, viewProjectionMatrix);
}

gl.bindFramebuffer(gl.FRAMEBUFFER, null);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

drawObjects(objectsToDraw);

requestAnimationFrame(drawScene);
}
</code></pre>
<p>Как видно, математика работает: мы рендерим только один пиксель
и всё равно определяем, что находится под мышью.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-picking-w-gpu-1pixel.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-picking-w-gpu-1pixel.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Эта оптимизация может быть полезна, если у вас много объектов
и вы хотите минимизировать использование памяти. Вместо создания
текстуры размером с canvas, вы создаете текстуру размером 1x1 пиксель.</p>
<p>Но есть компромисс. Теперь мы должны вычислять усеченную пирамиду
для каждого пикселя, что может быть дороже, чем просто создание
большей текстуры. Это зависит от вашего случая использования.</p>
<p>Также обратите внимание, что мы больше не читаем пиксель из позиции
мыши. Мы читаем пиксель из позиции (0,0), потому что теперь мы
рендерим только 1 пиксель в позиции (0,0) нашей 1x1 текстуры.</p>
<p>Это одна из многих техник, которые вы можете использовать для выбора
объектов в WebGL. Другие включают:</p>
<ol>
<li><strong>Ray casting</strong> - бросание луча из позиции мыши в 3D пространство</li>
<li><strong>Bounding box/sphere testing</strong> - проверка, находится ли точка внутри ограничивающего прямоугольника/сферы</li>
<li><strong>GPU picking</strong> - то, что мы только что сделали</li>
<li><strong>Hierarchical picking</strong> - выбор на основе иерархии объектов</li>
</ol>
<p>Каждая техника имеет свои преимущества и недостатки в зависимости
от вашего случая использования.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-picking.html" >English</a>
    <option value="/webgl/lessons/de/webgl-picking.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-picking.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-picking.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-picking.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-picking.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-picking.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-getting-webgl2.html">Как использовать WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как это работает</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 Диаграмма состояния</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl2-whats-new.html">Что нового в WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2.html">Переход с WebGL1 на WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2-fundamentals.html">Отличия от WebGLFundamentals.org до WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продвинутая обработка изображений</a></li>
        </ul>
  <li>2D трансформации, повороты, масштабирование и матричные операции</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D Трансляция</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D Вращение</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D Масштабирование</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D Матрицы</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">Ортографическая 3D</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">3D Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">3D - Камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-naming.html">3D - Именование матриц</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
        </ul>
  <li>Организация и рефакторинг</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">Меньше кода, больше удовольствия</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">Рисование множественных объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">Графы сцен</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">3D Геометрия - Токарная обработка</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Загрузка .obj файлов</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Загрузка .obj с .mtl файлами</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">Использование 2 или более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">Перспективно-корректное наложение текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Планарное и перспективное проекционное отображение</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
        </ul>
  <li>Тени</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Тени</a></li>
        </ul>
  <li>Техники</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">2D - Стек Матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Спрайты</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Кубические карты</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Карты окружения</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Скайбоксы</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Скининг</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Выбор объектов (клик по объектам)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">Текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">Текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">Текст - Использование текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">Текст - Использование текстуры глифов</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Самые маленькие программы</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Рисование без данных</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Вытягивание вершин</a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Индексированные вершины (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Инстансинг (Instanced Drawing)</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">Настройка и установка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Точки, линии и треугольники</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Множественные виды, множественные canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL2 и альфа-канал</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">2D против 3D библиотек</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">Анти-паттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL2 Матрицы против математических матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Проблемы точности</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Скриншот канваса</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Как не очищать канвас</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Получение ввода с клавиатуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Использование WebGL2 как фона в HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Справочник</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Атрибуты</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Текстурные юниты</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">Ссылки</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API документация</a></li>
  <li><a href="https://twgljs.org">TWGL, легковесная библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Есть предложения или замечания? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Создайте issue на GitHub</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Выбор объектов';
            var disqus_title = 'WebGL2 Выбор объектов';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Спасибо <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>за <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} вкладов</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



