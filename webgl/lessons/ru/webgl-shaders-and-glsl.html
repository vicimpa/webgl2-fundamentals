<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-shaders-and-glsl.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Что такое шейдер и что такое GLSL">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ru.jpg">

<meta property="og:title" content="WebGL2 Шейдеры и GLSL">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ru.jpg">
<meta property="og:description" content="Что такое шейдер и что такое GLSL">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shaders-and-glsl.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Шейдеры и GLSL">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shaders-and-glsl.html">
<meta name="twitter:description" content="Что такое шейдер и что такое GLSL">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shaders-and-glsl.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-shaders-and-glsl_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shaders-and-glsl.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shaders-and-glsl.html",
      "inLanguage":"ru",
      "name":"WebGL2 Шейдеры и GLSL",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-shaders-and-glsl.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Шейдеры и GLSL</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-shaders-and-glsl.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-shaders-and-glsl.html" >English</a>
    <option value="/webgl/lessons/de/webgl-shaders-and-glsl.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-shaders-and-glsl.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shaders-and-glsl.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-shaders-and-glsl.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-shaders-and-glsl.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html" >简体中文</a>
</select>


    <a href="#toc">Содержание</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Шейдеры и GLSL</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Это продолжение <a href="webgl-fundamentals.html">Основ WebGL</a>.
Если вы не читали о том, как работает WebGL, возможно, вы захотите <a href="webgl-how-it-works.html">сначала прочитать это</a>.</p>
<p>Мы говорили о шейдерах и GLSL, но не давали им никаких конкретных деталей.
Я думал, что это будет понятно на примерах, но давайте попробуем сделать это яснее на всякий случай.</p>
<p>Как упоминалось в <a href="webgl-how-it-works.html">как это работает</a>, WebGL требует 2 шейдера каждый раз, когда вы
что-то рисуете. <em>Вершинный шейдер</em> и <em>фрагментный шейдер</em>. Каждый шейдер - это <em>функция</em>. Вершинный
шейдер и фрагментный шейдер связаны вместе в шейдерную программу (или просто программу). Типичное
WebGL приложение будет иметь много шейдерных программ.</p>
<h2 id="вершинный-шейдер">Вершинный шейдер</h2>
<p>Задача вершинного шейдера - генерировать координаты clip space. Он всегда имеет форму</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
void main() {
   gl_Position = doMathToMakeClipspaceCoordinates
}
</code></pre>
<p>Ваш шейдер вызывается один раз для каждой вершины. Каждый раз, когда он вызывается, вы обязаны установить специальную глобальную переменную <code class="notranslate" translate="no">gl_Position</code> в некоторые координаты clip space.</p>
<p>Вершинным шейдерам нужны данные. Они могут получить эти данные 3 способами.</p>
<ol>
<li><a href="#attributes">Атрибуты</a> (данные, извлеченные из буферов)</li>
<li><a href="#uniforms">Uniforms</a> (значения, которые остаются одинаковыми для всех вершин одного вызова рисования)</li>
<li><a href="#textures-in-vertex-shaders">Текстуры</a> (данные из пикселей/текселей)</li>
</ol>
<h3 id="атрибуты">Атрибуты</h3>
<p>Самый распространенный способ для вершинного шейдера получить данные - через буферы и <em>атрибуты</em>.
<a href="webgl-how-it-works.html">Как это работает</a> покрывает буферы и
атрибуты. Вы создаете буферы,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var buf = gl.createBuffer();
</code></pre>
<p>помещаете данные в эти буферы</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, someData, gl.STATIC_DRAW);
</code></pre>
<p>Затем, учитывая шейдерную программу, которую вы создали, вы ищете местоположение ее атрибутов,</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var positionLoc = gl.getAttribLocation(someShaderProgram, &quot;a_position&quot;);
</code></pre>
<p>затем говорите WebGL, как извлекать данные из этих буферов и в атрибут</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// включаем получение данных из буфера для этого атрибута
gl.enableVertexAttribArray(positionLoc);

var numComponents = 3;  // (x, y, z)
var type = gl.FLOAT;
var normalize = false;  // оставляем значения как есть
var offset = 0;         // начинаем с начала буфера
var stride = 0;         // сколько байт переместиться к следующей вершине
                        // 0 = использовать правильный stride для type и numComponents

gl.vertexAttribPointer(positionLoc, numComponents, type, false, stride, offset);
</code></pre>
<p>В <a href="webgl-fundamentals.html">Основах WebGL</a> мы показали, что мы можем не делать математику
в шейдере и просто передавать данные напрямую.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

in vec4 a_position;

void main() {
   gl_Position = a_position;
}
</code></pre>
<p>Если мы поместим вершины clip space в наши буферы, это будет работать.</p>
<p>Атрибуты могут использовать <code class="notranslate" translate="no">float</code>, <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code>, <code class="notranslate" translate="no">vec4</code>, <code class="notranslate" translate="no">mat2</code>, <code class="notranslate" translate="no">mat3</code>, <code class="notranslate" translate="no">mat4</code>,
<code class="notranslate" translate="no">int</code>, <code class="notranslate" translate="no">ivec2</code>, <code class="notranslate" translate="no">ivec3</code>, <code class="notranslate" translate="no">ivec4</code>, <code class="notranslate" translate="no">uint</code>, <code class="notranslate" translate="no">uvec2</code>, <code class="notranslate" translate="no">uvec3</code>, <code class="notranslate" translate="no">uvec4</code> как типы.</p>
<h3 id="uniforms">Uniforms</h3>
<p>Для вершинного шейдера uniforms - это значения, передаваемые в вершинный шейдер, которые остаются одинаковыми
для всех вершин в вызове рисования. Как очень простой пример, мы могли бы добавить смещение к
вершинному шейдеру выше</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

in vec4 a_position;
+uniform vec4 u_offset;

void main() {
   gl_Position = a_position + u_offset;
}
</code></pre>
<p>И теперь мы могли бы сместить каждую вершину на определенное количество. Сначала мы бы нашли
местоположение uniform</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var offsetLoc = gl.getUniformLocation(someProgram, &quot;u_offset&quot;);
</code></pre>
<p>И затем перед рисованием мы бы установили uniform</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform4fv(offsetLoc, [1, 0, 0, 0]);  // смещаем вправо на половину экрана
</code></pre>
<p>Uniforms могут быть многих типов. Для каждого типа вы должны вызвать соответствующую функцию для его установки.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform1f (floatUniformLoc, v);                 // для float
gl.uniform1fv(floatUniformLoc, [v]);               // для float или массива float
gl.uniform2f (vec2UniformLoc,  v0, v1);            // для vec2
gl.uniform2fv(vec2UniformLoc,  [v0, v1]);          // для vec2 или массива vec2
gl.uniform3f (vec3UniformLoc,  v0, v1, v2);        // для vec3
gl.uniform3fv(vec3UniformLoc,  [v0, v1, v2]);      // для vec3 или массива vec3
gl.uniform4f (vec4UniformLoc,  v0, v1, v2, v4);    // для vec4
gl.uniform4fv(vec4UniformLoc,  [v0, v1, v2, v4]);  // для vec4 или массива vec4

gl.uniformMatrix2fv(mat2UniformLoc, false, [  4x element array ])  // для mat2 или массива mat2
gl.uniformMatrix3fv(mat3UniformLoc, false, [  9x element array ])  // для mat3 или массива mat3
gl.uniformMatrix4fv(mat4UniformLoc, false, [ 16x element array ])  // для mat4 или массива mat4

gl.uniform1i (intUniformLoc,   v);                 // для int
gl.uniform1iv(intUniformLoc, [v]);                 // для int или массива int
gl.uniform2i (ivec2UniformLoc, v0, v1);            // для ivec2
gl.uniform2iv(ivec2UniformLoc, [v0, v1]);          // для ivec2 или массива ivec2
gl.uniform3i (ivec3UniformLoc, v0, v1, v2);        // для ivec3
gl.uniform3iv(ivec3UniformLoc, [v0, v1, v2]);      // для ivec3 или массива ivec3
gl.uniform4i (ivec4UniformLoc, v0, v1, v2, v4);    // для ivec4
gl.uniform4iv(ivec4UniformLoc, [v0, v1, v2, v4]);  // для ivec4 или массива ivec4

gl.uniform1u (intUniformLoc,   v);                 // для uint
gl.uniform1uv(intUniformLoc, [v]);                 // для uint или массива uint
gl.uniform2u (ivec2UniformLoc, v0, v1);            // для uvec2
gl.uniform2uv(ivec2UniformLoc, [v0, v1]);          // для uvec2 или массива uvec2
gl.uniform3u (ivec3UniformLoc, v0, v1, v2);        // для uvec3
gl.uniform3uv(ivec3UniformLoc, [v0, v1, v2]);      // для uvec3 или массива uvec3
gl.uniform4u (ivec4UniformLoc, v0, v1, v2, v4);    // для uvec4
gl.uniform4uv(ivec4UniformLoc, [v0, v1, v2, v4]);  // для uvec4 или массива uvec4

// для sampler2D, sampler3D, samplerCube, samplerCubeShadow, sampler2DShadow,
// sampler2DArray, sampler2DArrayShadow
gl.uniform1i (samplerUniformLoc,   v);
gl.uniform1iv(samplerUniformLoc, [v]);
</code></pre>
<p>Есть также типы <code class="notranslate" translate="no">bool</code>, <code class="notranslate" translate="no">bvec2</code>, <code class="notranslate" translate="no">bvec3</code>, и <code class="notranslate" translate="no">bvec4</code>. Они используют либо функции <code class="notranslate" translate="no">gl.uniform?f?</code>, <code class="notranslate" translate="no">gl.uniform?i?</code>,
или <code class="notranslate" translate="no">gl.uniform?u?</code>.</p>
<p>Обратите внимание, что для массива вы можете установить все uniforms массива сразу. Например</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// в шейдере
uniform vec2 u_someVec2[3];

// в JavaScript во время инициализации
var someVec2Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2&quot;);

// во время рендеринга
gl.uniform2fv(someVec2Loc, [1, 2, 3, 4, 5, 6]);  // установить весь массив u_someVec2
</code></pre>
<p>Но если вы хотите установить отдельные элементы массива, вы должны найти местоположение
каждого элемента отдельно.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">// в JavaScript во время инициализации
var someVec2Element0Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[0]&quot;);
var someVec2Element1Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[1]&quot;);
var someVec2Element2Loc = gl.getUniformLocation(someProgram, &quot;u_someVec2[2]&quot;);

// во время рендеринга
gl.uniform2fv(someVec2Element0Loc, [1, 2]);  // установить элемент 0
gl.uniform2fv(someVec2Element1Loc, [3, 4]);  // установить элемент 1
gl.uniform2fv(someVec2Element2Loc, [5, 6]);  // установить элемент 2
</code></pre>
<p>Аналогично, если вы создаете структуру</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">struct SomeStruct {
  bool active;
  vec2 someVec2;
};
uniform SomeStruct u_someThing;
</code></pre>
<p>вы должны найти каждое поле отдельно</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var someThingActiveLoc = gl.getUniformLocation(someProgram, &quot;u_someThing.active&quot;);
var someThingSomeVec2Loc = gl.getUniformLocation(someProgram, &quot;u_someThing.someVec2&quot;);
</code></pre>
<h3 id="текстуры-в-вершинных-шейдерах">Текстуры в вершинных шейдерах</h3>
<p>См. <a href="#textures-in-fragment-shaders">Текстуры в фрагментных шейдерах</a>.</p>
<h2 id="фрагментный-шейдер">Фрагментный шейдер</h2>
<p>Задача фрагментного шейдера - предоставить цвет для текущего пикселя, который растеризуется.
Он всегда имеет форму</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
precision highp float;

out vec4 outColor;  // вы можете выбрать любое имя

void main() {
   outColor = doMathToMakeAColor;
} 
</code></pre>
<p>Ваш фрагментный шейдер вызывается один раз для каждого пикселя. Каждый раз, когда он вызывается, вы обязаны
установить вашу out переменную в какой-то цвет.</p>
<p>Фрагментным шейдерам нужны данные. Они могут получить данные 3 способами</p>
<ol>
<li><a href="#uniforms">Uniforms</a> (значения, которые остаются одинаковыми для каждого пикселя одного вызова рисования)</li>
<li><a href="#textures-in-fragment-shaders">Текстуры</a> (данные из пикселей/текселей)</li>
<li><a href="#varyings">Varyings</a> (данные, передаваемые из вершинного шейдера и интерполированные)</li>
</ol>
<h3 id="uniforms-в-фрагментных-шейдерах">Uniforms в фрагментных шейдерах</h3>
<p>См. <a href="#uniforms">Uniforms в вершинных шейдерах</a>.</p>
<h3 id="текстуры-в-фрагментных-шейдерах">Текстуры в фрагментных шейдерах</h3>
<p>Чтобы получить значение из текстуры в шейдере, мы создаем uniform <code class="notranslate" translate="no">sampler2D</code> и используем GLSL
функцию <code class="notranslate" translate="no">texture</code> для извлечения значения из неё.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">precision highp float;

uniform sampler2D u_texture;

out vec4 outColor;

void main() {
   vec2 texcoord = vec2(0.5, 0.5);  // получить значение из середины текстуры
   outColor = texture(u_texture, texcoord);
}
</code></pre>
<p>Какие данные выходят из текстуры, <a href="webgl-3d-textures.html">зависит от многих настроек</a>.
Как минимум нам нужно создать и поместить данные в текстуру, например</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
var level = 0;
var internalFormat = gl.RGBA,
var width = 2;
var height = 1;
var border = 0; // ВСЕГДА ДОЛЖЕН БЫТЬ НУЛЕМ
var format = gl.RGBA;
var type = gl.UNSIGNED_BYTE;
var data = new Uint8Array([255, 0, 0, 255, 0, 255, 0, 255]);
gl.texImage2D(gl.TEXTURE_2D,
              level,
              internalFormat,
              width,
              height,
              border,
              format,
              type,
              data);
</code></pre>
<p>Установить фильтрацию</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
</code></pre>
<p>Затем найти местоположение uniform в шейдерной программе</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var someSamplerLoc = gl.getUniformLocation(someProgram, &quot;u_texture&quot;);
</code></pre>
<p>WebGL затем требует, чтобы вы привязали его к текстуре unit</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">var unit = 5;  // Выберите какой-то текстуре unit
gl.activeTexture(gl.TEXTURE0 + unit);
gl.bindTexture(gl.TEXTURE_2D, tex);
</code></pre>
<p>И сказать шейдеру, к какому unit вы привязали текстуру</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">gl.uniform1i(someSamplerLoc, unit);
</code></pre>
<h3 id="varyings">Varyings</h3>
<p>Varying - это способ передать значение из вершинного шейдера в фрагментный шейдер, что мы
покрыли в <a href="webgl-how-it-works.html">как это работает</a>.</p>
<p>Чтобы использовать varying, нам нужно объявить соответствующие varyings в вершинном и фрагментном шейдере.
Мы устанавливаем <em>out</em> varying в вершинном шейдере с некоторым значением для каждой вершины. Когда WebGL рисует пиксели,
он будет опционально интерполировать между этими значениями и передавать их соответствующему <em>in</em> varying в
фрагментном шейдере</p>
<p>Вершинный шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es

in vec4 a_position;

uniform vec4 u_offset;

+out vec4 v_positionWithOffset;

void main() {
  gl_Position = a_position + u_offset;
+  v_positionWithOffset = a_position + u_offset;
}
</code></pre>
<p>Фрагментный шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">#version 300 es
precision highp float;

+in vec4 v_positionWithOffset;

out vec4 outColor;

void main() {
+  // конвертируем из clip space (-1 &lt;-&gt; +1) в цветовое пространство (0 -&gt; 1).
+  vec4 color = v_positionWithOffset * 0.5 + 0.5;
+  outColor = color;
}
</code></pre>
<p>Пример выше - это в основном бессмысленный пример. Обычно не имеет смысла
напрямую копировать значения clip space в фрагментный шейдер и использовать их как цвета. Тем не менее
это будет работать и производить цвета.</p>
<h2 id="glsl">GLSL</h2>
<p>GLSL означает <a href="https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf">Graphics Library Shader Language</a>.
Это язык, на котором написаны шейдеры. У него есть некоторые специальные полууникальные особенности, которые, конечно, не распространены в JavaScript.
Он разработан для выполнения математики, которая обычно нужна для вычисления вещей для растеризации
графики. Так, например, у него есть встроенные типы, такие как <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code> и <code class="notranslate" translate="no">vec4</code>, которые
представляют 2 значения, 3 значения и 4 значения соответственно. Аналогично у него есть <code class="notranslate" translate="no">mat2</code>, <code class="notranslate" translate="no">mat3</code>
и <code class="notranslate" translate="no">mat4</code>, которые представляют матрицы 2x2, 3x3 и 4x4. Вы можете делать такие вещи, как умножать
<code class="notranslate" translate="no">vec</code> на скаляр.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 a = vec4(1, 2, 3, 4);
vec4 b = a * 2.0;
// b теперь vec4(2, 4, 6, 8);
</code></pre>
<p>Аналогично он может делать умножение матриц и умножение вектора на матрицу</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">mat4 a = ???
mat4 b = ???
mat4 c = a * b;

vec4 v = ???
vec4 y = c * v;
</code></pre>
<p>У него также есть различные селекторы для частей vec. Для vec4</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 v;
</code></pre>
<ul>
<li><code class="notranslate" translate="no">v.x</code> то же самое, что <code class="notranslate" translate="no">v.s</code> и <code class="notranslate" translate="no">v.r</code> и <code class="notranslate" translate="no">v[0]</code>.</li>
<li><code class="notranslate" translate="no">v.y</code> то же самое, что <code class="notranslate" translate="no">v.t</code> и <code class="notranslate" translate="no">v.g</code> и <code class="notranslate" translate="no">v[1]</code>.</li>
<li><code class="notranslate" translate="no">v.z</code> то же самое, что <code class="notranslate" translate="no">v.p</code> и <code class="notranslate" translate="no">v.b</code> и <code class="notranslate" translate="no">v[2]</code>.</li>
<li><code class="notranslate" translate="no">v.w</code> то же самое, что <code class="notranslate" translate="no">v.q</code> и <code class="notranslate" translate="no">v.a</code> и <code class="notranslate" translate="no">v[3]</code>.</li>
</ul>
<p>Он способен <em>swizzle</em> компоненты vec, что означает, что вы можете поменять или повторить компоненты.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v.yyyy
</code></pre>
<p>то же самое, что</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.y, v.y, v.y, v.y)
</code></pre>
<p>Аналогично</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">v.bgra
</code></pre>
<p>то же самое, что</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.b, v.g, v.r, v.a)
</code></pre>
<p>При конструировании vec или mat вы можете предоставить несколько частей сразу. Так, например</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.rgb, 1)
</code></pre>
<p>То же самое, что</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4(v.r, v.g, v.b, 1)
</code></pre>
<p>Одна вещь, на которой вы, вероятно, застрянете, это то, что GLSL очень строго типизирован.</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">float f = 1;  // ОШИБКА 1 это int. Вы не можете присвоить int к float
</code></pre>
<p>Правильный способ - один из этих</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">float f = 1.0;      // использовать float
float f = float(1)  // привести целое число к float
</code></pre>
<p>Пример выше <code class="notranslate" translate="no">vec4(v.rgb, 1)</code> не жалуется на <code class="notranslate" translate="no">1</code>, потому что <code class="notranslate" translate="no">vec4</code> приводит
вещи внутри, как <code class="notranslate" translate="no">float(1)</code>.</p>
<p>GLSL имеет кучу встроенных функций. Многие из них работают с несколькими компонентами сразу.
Так, например</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">T sin(T angle)
</code></pre>
<p>Означает, что T может быть <code class="notranslate" translate="no">float</code>, <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code> или <code class="notranslate" translate="no">vec4</code>. Если вы передаете <code class="notranslate" translate="no">vec4</code>, вы получаете <code class="notranslate" translate="no">vec4</code> обратно,
который является синусом каждого из компонентов. Другими словами, если <code class="notranslate" translate="no">v</code> это <code class="notranslate" translate="no">vec4</code>, то</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 s = sin(v);
</code></pre>
<p>то же самое, что</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 s = vec4(sin(v.x), sin(v.y), sin(v.z), sin(v.w));
</code></pre>
<p>Иногда один аргумент - это float, а остальные - <code class="notranslate" translate="no">T</code>. Это означает, что этот float будет применен
ко всем компонентам. Например, если <code class="notranslate" translate="no">v1</code> и <code class="notranslate" translate="no">v2</code> это <code class="notranslate" translate="no">vec4</code>, а <code class="notranslate" translate="no">f</code> это float, то</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 m = mix(v1, v2, f);
</code></pre>
<p>то же самое, что</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">vec4 m = vec4(
  mix(v1.x, v2.x, f),
  mix(v1.y, v2.y, f),
  mix(v1.z, v2.z, f),
  mix(v1.w, v2.w, f));
</code></pre>
<p>Вы можете увидеть список всех GLSL функций на последних 3 страницах <a href="https://www.khronos.org/files/opengles3-quick-reference-card.pdf">OpenGL ES 3.0
Reference Card</a>
Если вам нравится действительно сухой и многословный материал, вы можете попробовать
<a href="https://www.khronos.org/registry/gles/specs/3.0/GLSL_ES_Specification_3.00.3.pdf">GLSL ES 3.00 spec</a>.</p>
<h2 id="собираем-все-вместе">Собираем все вместе</h2>
<p>В этом суть всей этой серии постов. WebGL - это все о создании различных шейдеров, предоставлении
данных этим шейдерам и затем вызове <code class="notranslate" translate="no">gl.drawArrays</code>, <code class="notranslate" translate="no">gl.drawElements</code> и т.д., чтобы WebGL обработал
вершины, вызывая текущий вершинный шейдер для каждой вершины, а затем рендерил пиксели, вызывая текущий фрагментный шейдер для каждого пикселя.</p>
<p>Фактически создание шейдеров требует нескольких строк кода. Поскольку эти строки одинаковы в
большинстве WebGL программ и поскольку однажды написанные, вы можете в значительной степени игнорировать их, <a href="webgl-boilerplate.html">как компилировать GLSL шейдеры
и связывать их в шейдерную программу, покрыто здесь</a>.</p>
<p>Если вы только начинаете отсюда, вы можете пойти в 2 направлениях. Если вас интересует обработка изображений,
я покажу вам <a href="webgl-image-processing.html">как делать некоторую 2D обработку изображений</a>.
Если вас интересует изучение перемещения,
поворота и масштабирования, то <a href="webgl-2d-translation.html">начните здесь</a>.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-shaders-and-glsl.html" >English</a>
    <option value="/webgl/lessons/de/webgl-shaders-and-glsl.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-shaders-and-glsl.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-shaders-and-glsl.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-shaders-and-glsl.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-shaders-and-glsl.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-getting-webgl2.html">Как использовать WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как это работает</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 Диаграмма состояния</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl2-whats-new.html">Что нового в WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2.html">Переход с WebGL1 на WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2-fundamentals.html">Отличия от WebGLFundamentals.org до WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продвинутая обработка изображений</a></li>
        </ul>
  <li>2D трансформации, повороты, масштабирование и матричные операции</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D Трансляция</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D Вращение</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D Масштабирование</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D Матрицы</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">Ортографическая 3D</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">3D Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">3D - Камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-naming.html">3D - Именование матриц</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
        </ul>
  <li>Организация и рефакторинг</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">Меньше кода, больше удовольствия</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">Рисование множественных объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">Графы сцен</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">3D Геометрия - Токарная обработка</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Загрузка .obj файлов</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Загрузка .obj с .mtl файлами</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">Использование 2 или более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">Перспективно-корректное наложение текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Планарное и перспективное проекционное отображение</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
        </ul>
  <li>Тени</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Тени</a></li>
        </ul>
  <li>Техники</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">2D - Стек Матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Спрайты</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Кубические карты</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Карты окружения</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Скайбоксы</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Скининг</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Выбор объектов (клик по объектам)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">Текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">Текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">Текст - Использование текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">Текст - Использование текстуры глифов</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Самые маленькие программы</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Рисование без данных</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Вытягивание вершин</a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Индексированные вершины (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Инстансинг (Instanced Drawing)</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">Настройка и установка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Точки, линии и треугольники</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Множественные виды, множественные canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL2 и альфа-канал</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">2D против 3D библиотек</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">Анти-паттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL2 Матрицы против математических матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Проблемы точности</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Скриншот канваса</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Как не очищать канвас</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Получение ввода с клавиатуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Использование WebGL2 как фона в HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Справочник</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Атрибуты</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Текстурные юниты</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">Ссылки</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API документация</a></li>
  <li><a href="https://twgljs.org">TWGL, легковесная библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Есть предложения или замечания? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Создайте issue на GitHub</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Шейдеры и GLSL';
            var disqus_title = 'WebGL2 Шейдеры и GLSL';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Спасибо <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>за <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} вкладов</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



