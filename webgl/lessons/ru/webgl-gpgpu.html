<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-gpgpu.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Как выполнять общие вычисления с помощью WebGL">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-gpgpu_ru.jpg">

<meta property="og:title" content="WebGL2 GPGPU">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-gpgpu_ru.jpg">
<meta property="og:description" content="Как выполнять общие вычисления с помощью WebGL">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 GPGPU">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html">
<meta name="twitter:description" content="Как выполнять общие вычисления с помощью WebGL">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-gpgpu_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-gpgpu_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html",
      "inLanguage":"ru",
      "name":"WebGL2 GPGPU",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-gpgpu.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 GPGPU</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-gpgpu.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-gpgpu.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-gpgpu.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-gpgpu.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-gpgpu.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-gpgpu.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-gpgpu.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-gpgpu.html" >English</a>
    <option value="/webgl/lessons/de/webgl-gpgpu.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-gpgpu.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-gpgpu.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-gpgpu.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-gpgpu.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-gpgpu.html" >简体中文</a>
</select>


    <a href="#toc">Содержание</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 GPGPU</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>GPGPU означает “General Purpose” GPU и означает использование GPU для чего-то
другого, кроме рисования пикселей.</p>
<p>Основное понимание для осознания GPGPU в WebGL заключается в том, что текстура</p>
<ul>
<li>это не изображение, а 2D массив значений. В <a href="webgl-3d-textures.html">статье о текстурах</a>
мы рассмотрели чтение из текстуры. В <a href="webgl-render-to-texture.html">статье о рендеринге в текстуру</a>
мы рассмотрели запись в текстуру. Итак, если осознать, что текстура - это 2D массив значений,
мы можем сказать, что мы действительно описали способ чтения из и записи в 2D массивы.
Аналогично буфер - это не просто позиции, нормали, координаты текстуры и цвета.
Эти данные могут быть чем угодно. Скорости, массы, цены акций и т.д.
Творческое использование этих знаний для выполнения математики - это суть GPGPU в WebGL.</li>
</ul>
<h2 id="сначала-сделаем-это-с-текстурами">Сначала сделаем это с текстурами</h2>
<p>В JavaScript есть функция <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code class="notranslate" translate="no">Array.prototype.map</code></a>, которая для данного массива вызывает функцию для каждого элемента</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function multBy2(v) {
  return v * 2;
}

const src = [1, 2, 3, 4, 5, 6];
const dst = src.map(multBy2);

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<p>Вы можете рассматривать <code class="notranslate" translate="no">multBy2</code> как шейдер, а <code class="notranslate" translate="no">map</code> как аналогичный вызову <code class="notranslate" translate="no">gl.drawArrays</code> или <code class="notranslate" translate="no">gl.drawElements</code>.
Некоторые различия.</p>
<h2 id="шейдеры-не-генерируют-новый-массив-вы-должны-предоставить-его">Шейдеры не генерируют новый массив, вы должны предоставить его</h2>
<p>Мы можем симулировать это, создав собственную функцию map</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function multBy2(v) {
  return v * 2;
}

function mapSrcToDst(src, fn, dst) {
  for (let i = 0; i &lt; src.length; ++i) {
    dst[i] = fn(src[i]);
  }
}

const src = [1, 2, 3, 4, 5, 6];
const dst = new Array(6);    // чтобы симулировать, что в WebGL мы должны выделить текстуру
mapSrcToDst(src, multBy2, dst);

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<h2 id="шейдеры-не-возвращают-значение-они-устанавливают-переменную-out">Шейдеры не возвращают значение, они устанавливают переменную <code class="notranslate" translate="no">out</code></h2>
<p>Это довольно легко симулировать</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let outColor;

function multBy2(v) {
  outColor = v * 2;
}

function mapSrcToDst(src, fn, dst) {
  for (let i = 0; i &lt; src.length; ++i) {
    fn(src[i]);
    dst[i] = outColor;
  }
}

const src = [1, 2, 3, 4, 5, 6];
const dst = new Array(6);    // чтобы симулировать, что в WebGL мы должны выделить текстуру
mapSrcToDst(src, multBy2, dst);

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<h2 id="шейдеры-основаны-на-назначении-а-не-на-источнике">Шейдеры основаны на назначении, а не на источнике.</h2>
<p>Другими словами, они перебирают назначение и спрашивают “какое значение я должен положить сюда”</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let outColor;

function multBy2(src) {
  return function(i) {
    outColor = src[i] * 2;
  }
}

function mapDst(dst, fn) {
  for (let i = 0; i &lt; dst.length; ++i) {    
    fn(i);
    dst[i] = outColor;
  }
}

const src = [1, 2, 3, 4, 5, 6];
const dst = new Array(6);    // чтобы симулировать, что в WebGL мы должны выделить текстуру
mapDst(dst, multBy2(src));

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<h2 id="в-webgl-индекс-или-id-пикселя-значение-которого-вас-просят-предоставить-называется-gl_fragcoord">В WebGL индекс или ID пикселя, значение которого вас просят предоставить, называется <code class="notranslate" translate="no">gl_FragCoord</code></h2>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let outColor;
let gl_FragCoord;

function multBy2(src) {
  return function() {
    outColor = src[gl_FragCoord] * 2;
  }
}

function mapDst(dst, fn) {
  for (let i = 0; i &lt; dst.length; ++i) {    
    gl_FragCoord = i;
    fn();
    dst[i] = outColor;
  }
}

const src = [1, 2, 3, 4, 5, 6];
const dst = new Array(6);    // чтобы симулировать, что в WebGL мы должны выделить текстуру
mapDst(dst, multBy2(src));

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<h2 id="в-webgl-текстуры---это-2d-массивы">В WebGL текстуры - это 2D массивы.</h2>
<p>Давайте предположим, что наш массив <code class="notranslate" translate="no">dst</code> представляет текстуру 3x2</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let outColor;
let gl_FragCoord;

function multBy2(src, across) {
  return function() {
    outColor = src[gl_FragCoord.y * across + gl_FragCoord.x] * 2;
  }
}

function mapDst(dst, across, up, fn) {
  for (let y = 0; y &lt; up; ++y) {
    for (let x = 0; x &lt; across; ++x) {
      gl_FragCoord = {x, y};
      fn();
      dst[y * across + x] = outColor;
    }
  }
}

const src = [1, 2, 3, 4, 5, 6];
const dst = new Array(6);    // чтобы симулировать, что в WebGL мы должны выделить текстуру
mapDst(dst, 3, 2, multBy2(src, 3));

// dst теперь [2, 4, 6, 8, 10, 12];
</code></pre>
<p>И мы могли бы продолжать. Я надеюсь, что примеры выше помогают вам увидеть, что GPGPU в WebGL
довольно прост концептуально. Давайте действительно сделаем вышесказанное в WebGL.</p>
<p>Для понимания следующего кода вам нужно будет, как минимум, прочитать
<a href="webgl-fundamentals.html">статью об основах</a>, вероятно, статью о
<a href="webgl-how-it-works.html">Как это работает</a>, статью о <a href="webgl-shaders-and-glsl.html">GLSL</a>
и <a href="webgl-3d-textures.html">статью о текстурах</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `#version 300 es
in vec4 position;
void main() {
  gl_Position = position;
}
`;

const fs = `#version 300 es
precision highp float;

uniform sampler2D srcTex;

out vec4 outColor;

void main() {
  ivec2 texelCoord = ivec2(gl_FragCoord.xy);
  vec4 value = texelFetch(srcTex, texelCoord, 0);  // 0 = mip level 0
  outColor = value * 2.0;
}
`;

const dstWidth = 3;
const dstHeight = 2;

// создаем canvas 3x2 для 6 результатов
const canvas = document.createElement('canvas');
canvas.width = dstWidth;
canvas.height = dstHeight;

const gl = canvas.getContext('webgl2');

const program = webglUtils.createProgramFromSources(gl, [vs, fs]);
const positionLoc = gl.getAttribLocation(program, 'position');
const srcTexLoc = gl.getUniformLocation(program, 'srcTex');

// настраиваем полноэкранный quad в clip space
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1,
   1, -1,
  -1,  1,
  -1,  1,
   1, -1,
   1,  1,
]), gl.STATIC_DRAW);

// Создаем объект вершинного массива (состояние атрибутов)
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

// настраиваем наши атрибуты, чтобы сказать WebGL, как извлекать
// данные из буфера выше в атрибут position
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(
    positionLoc,
    2,         // размер (количество компонентов)
    gl.FLOAT,  // тип данных в буфере
    false,     // нормализовать
    0,         // шаг (0 = авто)
    0,         // смещение
);

// создаем нашу исходную текстуру
const srcWidth = 3;
const srcHeight = 2;
const tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1); // см. https://webglfundamentals.org/webgl/lessons/webgl-data-textures.html
gl.texImage2D(
    gl.TEXTURE_2D,
    0,                // mip уровень
    gl.R8,            // внутренний формат
    srcWidth,
    srcHeight,
    0,                // граница
    gl.RED,           // формат
    gl.UNSIGNED_BYTE, // тип
    new Uint8Array([
      1, 2, 3,
      4, 5, 6,
    ]));
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

gl.useProgram(program);
gl.uniform1i(srcTexLoc, 0);  // говорим шейдеру, что исходная текстура находится на texture unit 0

gl.drawArrays(gl.TRIANGLES, 0, 6);  // рисуем 2 треугольника (6 вершин)

// получаем результат
const results = new Uint8Array(dstWidth * dstHeight * 4);
gl.readPixels(0, 0, dstWidth, dstHeight, gl.RGBA, gl.UNSIGNED_BYTE, results);

// выводим результаты
for (let i = 0; i &lt; dstWidth * dstHeight; ++i) {
  log(results[i * 4]);
}
</code></pre>
<p>и вот он работает</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-gpgpu-mult-by-2.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-gpgpu-mult-by-2.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Некоторые замечания о коде выше.</p>
<ul>
<li>
<p>Мы рисуем quad в clip space от -1 до +1.</p>
<p>Мы создаем вершины для quad от -1 до +1 из 2 треугольников. Это означает, что при правильной настройке viewport
мы нарисуем все пиксели в назначении. Другими словами, мы попросим
наш шейдер сгенерировать значение для каждого элемента в результирующем массиве. Этот массив в
данном случае - это сам canvas.</p>
</li>
<li>
<p><code class="notranslate" translate="no">texelFetch</code> - это функция текстуры, которая ищет один texel из текстуры.</p>
<p>Она принимает 3 параметра. Сэмплер, координаты texel на основе целых чисел, и mip уровень.
<code class="notranslate" translate="no">gl_FragCoord</code> - это vec2, нам нужно превратить его в <code class="notranslate" translate="no">ivec2</code>, чтобы использовать с
<code class="notranslate" translate="no">texelFetch</code>. Здесь нет дополнительной математики, пока исходная текстура и
текстура назначения имеют одинаковый размер, что в данном случае так и есть.</p>
</li>
<li>
<p>Наш шейдер записывает 4 значения на пиксель</p>
<p>В данном конкретном случае это влияет на то, как мы читаем вывод. Мы просим <code class="notranslate" translate="no">RGBA/UNSIGNED_BYTE</code>
из <code class="notranslate" translate="no">readPixels</code> <a href="webgl-readpixels.html">потому что другие комбинации формата/типа не поддерживаются</a>.
Поэтому нам нужно смотреть на каждое 4-е значение для нашего ответа.</p>
<p>Примечание: Было бы умно попытаться воспользоваться тем фактом, что WebGL делает 4 значения за раз
для еще большей скорости.</p>
</li>
<li>
<p>Мы используем <code class="notranslate" translate="no">R8</code> как внутренний формат нашей текстуры.</p>
<p>Это означает, что только красный канал из текстуры имеет значение из наших данных.</p>
</li>
<li>
<p>И наши входные данные, и выходные данные (canvas) - это значения <code class="notranslate" translate="no">UNSIGNED_BYTE</code></p>
<p>Это означает, что мы можем передавать и получать обратно только целые значения от 0 до 255.
Мы могли бы использовать разные форматы для ввода, предоставляя текстуру другого формата.
Мы также могли бы попытаться рендерить в текстуру другого формата для большего диапазона выходных значений.</p>
</li>
</ul>
<p>В примере выше src и dst имеют одинаковый размер. Давайте изменим это так, чтобы мы добавляли каждые 2 значения
из src, чтобы сделать dst. Другими словами, учитывая <code class="notranslate" translate="no">[1, 2, 3, 4, 5, 6]</code> как ввод, мы хотим
<code class="notranslate" translate="no">[3, 7, 11]</code> как вывод. И далее, давайте сохраним источник как данные 3x2</p>
<p>Основная формула для получения значения из 2D массива, как если бы это был 1D массив</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">y = floor(indexInto1DArray / widthOf2DArray);
x = indexInto1DArray % widthOf2Array;
</code></pre>
<p>Учитывая это, наш фрагментный шейдер должен измениться на это, чтобы добавить каждые 2 значения.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

uniform sampler2D srcTex;
uniform ivec2 dstDimensions;

out vec4 outColor;

vec4 getValueFrom2DTextureAs1DArray(sampler2D tex, ivec2 dimensions, int index) {
  int y = index / dimensions.x;
  int x = index % dimensions.x;
  return texelFetch(tex, ivec2(x, y), 0);
}

void main() {
  // вычисляем 1D индекс в dst
  ivec2 dstPixel = ivec2(gl_FragCoord.xy);
  int dstIndex = dstPixel.y * dstDimensions.x + dstPixel.x;

  ivec2 srcDimensions = textureSize(srcTex, 0);  // размер mip 0

  vec4 v1 = getValueFrom2DTextureAs1DArray(srcTex, srcDimensions, dstIndex * 2);
  vec4 v2 = getValueFrom2DTextureAs1DArray(srcTex, srcDimensions, dstIndex * 2 + 1);

  outColor = v1 + v2;
}
</code></pre>
<p>Функция <code class="notranslate" translate="no">getValueFrom2DTextureAs1DArray</code> - это в основном наша функция доступа к массиву.
Это означает, что эти 2 строки</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">  vec4 v1 = getValueFrom2DTextureAs1DArray(srcTex, srcDimensions, dstIndex * 2.0);
  vec4 v2 = getValueFrom2DTextureAs1DArray(srcTex, srcDimensions, dstIndex * 2.0 + 1.0);
</code></pre>
<p>Эффективно означают это</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">  vec4 v1 = srcTexAs1DArray[dstIndex * 2.0];
  vec4 v2 = setTexAs1DArray[dstIndex * 2.0 + 1.0];
</code></pre>
<p>В нашем JavaScript нам нужно найти местоположение <code class="notranslate" translate="no">dstDimensions</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const program = webglUtils.createProgramFromSources(gl, [vs, fs]);
const positionLoc = gl.getAttribLocation(program, 'position');
const srcTexLoc = gl.getUniformLocation(program, 'srcTex');
const dstDimensionsLoc = gl.getUniformLocation(program, 'dstDimensions');
</code></pre>
<p>и установить его</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.useProgram(program);
gl.uniform1i(srcTexLoc, 0);  // говорим шейдеру, что исходная текстура находится на texture unit 0
gl.uniform2f(dstDimensionsLoc, dstWidth, dstHeight);
</code></pre>
<p>и нам нужно изменить размер назначения (canvas)</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const dstWidth = 3;
const dstHeight = 1;
</code></pre>
<p>и с этим у нас теперь есть результирующий массив, способный выполнять математику
со случайным доступом в исходный массив</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-gpgpu-add-2-elements.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-gpgpu-add-2-elements.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Если вы хотели бы использовать больше массивов как ввод, просто добавьте больше текстур, чтобы поместить больше
данных в ту же текстуру.</p>
<h2 id="теперь-сделаем-это-с-transform-feedback">Теперь сделаем это с <em>transform feedback</em></h2>
<p>“Transform Feedback” - это модное название для способности записывать вывод
varyings в вершинном шейдере в один или несколько буферов.</p>
<p>Преимущество использования transform feedback в том, что вывод одномерный,
поэтому, вероятно, легче рассуждать об этом. Это даже ближе к <code class="notranslate" translate="no">map</code> из JavaScript.</p>
<p>Давайте возьмем 2 массива значений и выведем их сумму, разность
и произведение. Вот вершинный шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es

in float a;
in float b;

out float sum;
out float difference;
out float product;

void main() {
  sum = a + b;
  difference = a - b;
  product = a * b;
}
</code></pre>
<p>и фрагментный шейдер просто достаточно для компиляции</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;
void main() {
}
</code></pre>
<p>Чтобы использовать transform feedback, мы должны сказать WebGL, какие varyings мы хотим записать
и в каком порядке. Мы делаем это, вызывая <code class="notranslate" translate="no">gl.transformFeedbackVaryings</code> перед
линковкой шейдерной программы. Из-за этого мы не будем использовать наш помощник
для компиляции шейдеров и линковки программы на этот раз, просто чтобы было ясно,
что мы должны сделать.</p>
<p>Итак, вот код для компиляции шейдера, аналогичный коду в самой
<a href="webgl-fundamentals.html">первой статье</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function createShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(shader));
  }
  return shader;
}
</code></pre>
<p>Мы будем использовать его для компиляции наших 2 шейдеров, а затем прикрепить их и вызвать
<code class="notranslate" translate="no">gl.transformFeedbackVaryings</code> перед линковкой</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vShader = createShader(gl, gl.VERTEX_SHADER, vs);
const fShader = createShader(gl, gl.FRAGMENT_SHADER, fs);

const program = gl.createProgram();
gl.attachShader(program, vShader);
gl.attachShader(program, fShader);
gl.transformFeedbackVaryings(
    program,
    ['sum', 'difference', 'product'],
    gl.SEPARATE_ATTRIBS,
);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  throw new Error(gl.getProgramParameter(program));
}
</code></pre>
<p><code class="notranslate" translate="no">gl.transformFeedbackVaryings</code> принимает 3 аргумента. Программу, массив имен
varyings, которые мы хотим записать в том порядке, в котором вы хотите их записать.
Если бы у вас был фрагментный шейдер, который действительно что-то делал,
то, возможно, некоторые из ваших varyings предназначены только для фрагментного шейдера и поэтому
не нуждаются в записи. В нашем случае мы запишем все наши varyings, поэтому передаем
имена всех 3. Последний параметр может быть одним из 2 значений. Либо <code class="notranslate" translate="no">SEPARATE_ATTRIBS</code>,
либо <code class="notranslate" translate="no">INTERLEAVED_ATTRIBS</code>.</p>
<p><code class="notranslate" translate="no">SEPARATE_ATTRIBS</code> означает, что каждый varying будет записан в другой буфер.
<code class="notranslate" translate="no">INTERLEAVED_ATTRIBS</code> означает, что все varyings будут записаны в тот же буфер,
но перемежаться в том порядке, который мы указали. В нашем случае, поскольку мы указали
<code class="notranslate" translate="no">['sum', 'difference', 'product']</code>, если бы мы использовали <code class="notranslate" translate="no">INTERLEAVED_ATTRIBS</code>, вывод
был бы <code class="notranslate" translate="no">sum0, difference0, product0, sum1, difference1, product1, sum2, difference2, product2, etc...</code>
в один буфер. Мы используем <code class="notranslate" translate="no">SEPARATE_ATTRIBS</code>, поэтому вместо этого
каждый вывод будет записан в другой буфер.</p>
<p>Итак, как и в других примерах, нам нужно настроить буферы для наших входных атрибутов</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const aLoc = gl.getAttribLocation(program, 'a');
const bLoc = gl.getAttribLocation(program, 'b');

// Создаем объект вершинного массива (состояние атрибутов)
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

function makeBuffer(gl, sizeOrData) {
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, sizeOrData, gl.STATIC_DRAW);
  return buf;
}

function makeBufferAndSetAttribute(gl, data, loc) {
  const buf = makeBuffer(gl, data);
  // настраиваем наши атрибуты, чтобы сказать WebGL, как извлекать
  // данные из буфера выше в атрибут
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(
      loc,
      1,         // размер (количество компонентов)
      gl.FLOAT,  // тип данных в буфере
      false,     // нормализовать
      0,         // шаг (0 = авто)
      0,         // смещение
  );
}

const a = [1, 2, 3, 4, 5, 6];
const b = [3, 6, 9, 12, 15, 18];

// помещаем данные в буферы
const aBuffer = makeBufferAndSetAttribute(gl, new Float32Array(a), aLoc);
const bBuffer = makeBufferAndSetAttribute(gl, new Float32Array(b), bLoc);
</code></pre>
<p>Затем нам нужно настроить “transform feedback”. “Transform feedback” - это объект,
который содержит состояние буферов, в которые мы будем записывать. В то время как <a href="webgl-attributes.html">вершинный массив</a>
указывает состояние всех входных атрибутов, “transform feedback” содержит
состояние всех выходных атрибутов.</p>
<p>Вот код для настройки нашего</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Создаем и заполняем transform feedback
const tf = gl.createTransformFeedback();
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);

// создаем буферы для вывода
const sumBuffer = makeBuffer(gl, a.length * 4);
const differenceBuffer = makeBuffer(gl, a.length * 4);
const productBuffer = makeBuffer(gl, a.length * 4);

// привязываем буферы к transform feedback
gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, sumBuffer);
gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, differenceBuffer);
gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 2, productBuffer);

gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

// буферы, в которые мы записываем, не могут быть привязаны где-то еще
gl.bindBuffer(gl.ARRAY_BUFFER, null);  // productBuffer все еще был привязан к ARRAY_BUFFER, поэтому отвязываем его
</code></pre>
<p>Мы вызываем <code class="notranslate" translate="no">bindBufferBase</code>, чтобы установить, в какой буфер каждый из выходов, выход 0, выход 1 и выход 2
будет записывать. Выходы 0, 1, 2 соответствуют именам, которые мы передали в <code class="notranslate" translate="no">gl.transformFeedbackVaryings</code>
когда мы линковали программу.</p>
<p>Когда мы закончили, “transform feedback”, который мы создали, имеет состояние, как это</p>
<img src="../resources/transform-feedback-diagram.png" style="width: 625px;" class="webgl_center">
<p>Есть также функция <code class="notranslate" translate="no">bindBufferRange</code>, которая позволяет нам указать поддиапазон в буфере, где
мы будем записывать, но мы не будем использовать это здесь.</p>
<p>Итак, чтобы выполнить шейдер, мы делаем это</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.useProgram(program);

// привязываем наше состояние входных атрибутов для буферов a и b
gl.bindVertexArray(vao);

// нет необходимости вызывать фрагментный шейдер
gl.enable(gl.RASTERIZER_DISCARD);

gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
gl.beginTransformFeedback(gl.POINTS);
gl.drawArrays(gl.POINTS, 0, a.length);
gl.endTransformFeedback();
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

// включаем использование фрагментных шейдеров снова
gl.disable(gl.RASTERIZER_DISCARD);
</code></pre>
<p>Мы отключаем вызов фрагментного шейдера. Мы привязываем объект transform feedback,
который мы создали ранее, мы включаем transform feedback, затем мы вызываем draw.</p>
<p>Чтобы посмотреть на значения, мы можем вызвать <code class="notranslate" translate="no">gl.getBufferSubData</code></p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">log(`a: ${a}`);
log(`b: ${b}`);

printResults(gl, sumBuffer, 'sums');
printResults(gl, differenceBuffer, 'differences');
printResults(gl, productBuffer, 'products');

function printResults(gl, buffer, label) {
  const results = new Float32Array(a.length);
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.getBufferSubData(
      gl.ARRAY_BUFFER,
      0,    // смещение в байтах в GPU буфере,
      results,
  );
  // выводим результаты
  log(`${label}: ${results}`);
}
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-gpgpu-sum-difference-product-transformfeedback.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-gpgpu-sum-difference-product-transformfeedback.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Вы можете видеть, что это сработало. Мы заставили GPU вычислить сумму, разность и произведение
значений ‘a’ и ‘b’, которые мы передали.</p>
<p>Примечание: Вы можете найти <a href="https://webgl2fundamentals.org/webgl/lessons/resources/webgl-state-diagram.html?exampleId=transform-feedback">этот пример диаграммы состояния transform feedback</a> полезным для визуализации того, что такое “transform feedback”.
Это не тот же пример, что выше, хотя. Вершинный шейдер, который он использует с transform feedback, генерирует позиции и цвета для круга точек.</p>
<h2 id="первый-пример-частицы">Первый пример: частицы</h2>
<p>Допустим, у вас есть очень простая система частиц.
Каждая частица просто имеет позицию и скорость, и
если она выходит за один край экрана, она оборачивается вокруг
другой стороны.</p>
<p>Учитывая большинство других статей на этом сайте, вы бы
обновляли позиции частиц в JavaScript</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">for (const particle of particles) {
  particle.pos.x = (particle.pos.x + particle.velocity.x) % canvas.width;
  particle.pos.y = (particle.pos.y + particle.velocity.y) % canvas.height;
}
</code></pre>
<p>и затем рисовали бы частицы либо по одной за раз</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">useProgram (particleShader)
setup particle attributes
for each particle
  set uniforms
  draw particle
</code></pre>
<p>Или вы могли бы загрузить все новые позиции частиц</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">bindBuffer(..., particlePositionBuffer)
bufferData(..., latestParticlePositions, ...)
useProgram (particleShader)
setup particle attributes
set uniforms
draw particles
</code></pre>
<p>Используя пример transform feedback выше, мы могли бы создать
буфер со скоростью для каждой частицы. Затем мы могли бы
создать 2 буфера для позиций. Мы использовали бы transform feedback
для добавления скорости к одному буферу позиций и записи в
другой буфер позиций. Затем мы рисовали бы с новыми позициями.
На следующем кадре мы читали бы из буфера с новыми позициями
и записывали обратно в другой буфер для генерации еще более новых позиций.</p>
<p>Вот вершинный шейдер для обновления позиций частиц</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
in vec2 oldPosition;
in vec2 velocity;

uniform float deltaTime;
uniform vec2 canvasDimensions;

out vec2 newPosition;

vec2 euclideanModulo(vec2 n, vec2 m) {
	return mod(mod(n, m) + m, m);
}

void main() {
  newPosition = euclideanModulo(
      oldPosition + velocity * deltaTime,
      canvasDimensions);
}
</code></pre>
<p>Чтобы рисовать частицы, мы просто используем простой вершинный шейдер</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
in vec4 position;
uniform mat4 matrix;

void main() {
  // делаем общую матричную математику
  gl_Position = matrix * position;
  gl_PointSize = 10.0;
}
</code></pre>
<p>Давайте превратим код для создания и линковки программы в
функцию, которую мы можем использовать для обоих шейдеров</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function createProgram(gl, shaderSources, transformFeedbackVaryings) {
  const program = gl.createProgram();
  [gl.VERTEX_SHADER, gl.FRAGMENT_SHADER].forEach((type, ndx) =&gt; {
    const shader = createShader(gl, type, shaderSources[ndx]);
    gl.attachShader(program, shader);
  });
  if (transformFeedbackVaryings) {
    gl.transformFeedbackVaryings(
        program,
        transformFeedbackVaryings,
        gl.SEPARATE_ATTRIBS,
    );
  }
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error(gl.getProgramParameter(program));
  }
  return program;
}
</code></pre>
<p>и затем использовать его для компиляции шейдеров, один с transform feedback
varying.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const updatePositionProgram = createProgram(
    gl, [updatePositionVS, updatePositionFS], ['newPosition']);
const drawParticlesProgram = createProgram(
    gl, [drawParticlesVS, drawParticlesFS]);
</code></pre>
<p>Как обычно, нам нужно найти местоположения</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const updatePositionPrgLocs = {
  oldPosition: gl.getAttribLocation(updatePositionProgram, 'oldPosition'),
  velocity: gl.getAttribLocation(updatePositionProgram, 'velocity'),
  canvasDimensions: gl.getUniformLocation(updatePositionProgram, 'canvasDimensions'),
  deltaTime: gl.getUniformLocation(updatePositionProgram, 'deltaTime'),
};

const drawParticlesProgLocs = {
  position: gl.getAttribLocation(drawParticlesProgram, 'position'),
  matrix: gl.getUniformLocation(drawParticlesProgram, 'matrix'),
};
</code></pre>
<p>Теперь давайте создадим некоторые случайные позиции и скорости</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// создаем случайные позиции и скорости.
const rand = (min, max) =&gt; {
  if (max === undefined) {
    max = min;
    min = 0;
  }
  return Math.random() * (max - min) + min;
};
const numParticles = 200;
const createPoints = (num, ranges) =&gt;
   new Array(num).fill(0).map(_ =&gt; ranges.map(range =&gt; rand(...range))).flat();
const positions = new Float32Array(createPoints(numParticles, [[canvas.width], [canvas.height]]));
const velocities = new Float32Array(createPoints(numParticles, [[-300, 300], [-300, 300]]));
</code></pre>
<p>Затем мы поместим их в буферы.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function makeBuffer(gl, sizeOrData, usage) {
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, sizeOrData, usage);
  return buf;
}

const position1Buffer = makeBuffer(gl, positions, gl.DYNAMIC_DRAW);
const position2Buffer = makeBuffer(gl, positions, gl.DYNAMIC_DRAW);
const velocityBuffer = makeBuffer(gl, velocities, gl.STATIC_DRAW);
</code></pre>
<p>Обратите внимание, что мы передали <code class="notranslate" translate="no">gl.DYNAMIC_DRAW</code> в <code class="notranslate" translate="no">gl.bufferData</code> для 2 буферов позиций,
поскольку мы будем обновлять их часто. Это просто подсказка для WebGL для оптимизации.
Имеет ли это какой-либо эффект на производительность, зависит от WebGL.</p>
<p>Нам нужно 4 вершинных массива.</p>
<ul>
<li>1 для использования <code class="notranslate" translate="no">position1Buffer</code> и <code class="notranslate" translate="no">velocity</code> при обновлении позиций</li>
<li>1 для использования <code class="notranslate" translate="no">position2Buffer</code> и <code class="notranslate" translate="no">velocity</code> при обновлении позиций</li>
<li>1 для использования <code class="notranslate" translate="no">position1Buffer</code> при рисовании</li>
<li>1 для использования <code class="notranslate" translate="no">position2Buffer</code> при рисовании</li>
</ul>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function makeVertexArray(gl, bufLocPairs) {
  const va = gl.createVertexArray();
  gl.bindVertexArray(va);
  for (const [buffer, loc] of bufLocPairs) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(
        loc,      // местоположение атрибута
        2,        // количество элементов
        gl.FLOAT, // тип данных
        false,    // нормализовать
        0,        // шаг (0 = авто)
        0,        // смещение
    );
  }
  return va;
}

const updatePositionVA1 = makeVertexArray(gl, [
  [position1Buffer, updatePositionPrgLocs.oldPosition],
  [velocityBuffer, updatePositionPrgLocs.velocity],
]);
const updatePositionVA2 = makeVertexArray(gl, [
  [position2Buffer, updatePositionPrgLocs.oldPosition],
  [velocityBuffer, updatePositionPrgLocs.velocity],
]);

const drawVA1 = makeVertexArray(
    gl, [[position1Buffer, drawParticlesProgLocs.position]]);
const drawVA2 = makeVertexArray(
    gl, [[position2Buffer, drawParticlesProgLocs.position]]);
</code></pre>
<p>Затем мы создаем 2 объекта transform feedback.</p>
<ul>
<li>1 для записи в <code class="notranslate" translate="no">position1Buffer</code></li>
<li>1 для записи в <code class="notranslate" translate="no">position2Buffer</code></li>
</ul>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function makeTransformFeedback(gl, buffer) {
  const tf = gl.createTransformFeedback();
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, tf);
  gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, buffer);
  return tf;
}

const tf1 = makeTransformFeedback(gl, position1Buffer);
const tf2 = makeTransformFeedback(gl, position2Buffer);
</code></pre>
<p>При использовании transform feedback важно отвязать буферы
от других точек привязки. <code class="notranslate" translate="no">ARRAY_BUFFER</code> все еще имеет последний буфер
привязанным, в который мы поместили данные. <code class="notranslate" translate="no">TRANSFORM_FEEDBACK_BUFFER</code> устанавливается при
вызове <code class="notranslate" translate="no">gl.bindBufferBase</code>. Это немного запутанно. Вызов
<code class="notranslate" translate="no">gl.bindBufferBase</code> с <code class="notranslate" translate="no">TRANSFORM_FEEDBACK_BUFFER</code> фактически
привязывает буфер к 2 местам. Одно - к индексированной точке привязки внутри
объекта transform feedback. Другое - к своего рода глобальной
точке привязки, называемой <code class="notranslate" translate="no">TRANSFORM_FEEDBACK_BUFFER</code>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// отвязываем оставшиеся вещи
gl.bindBuffer(gl.ARRAY_BUFFER, null);
gl.bindBuffer(gl.TRANSFORM_FEEDBACK_BUFFER, null);
</code></pre>
<p>Чтобы мы могли легко менять местами буферы обновления и рисования,
мы настроим эти 2 объекта</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let current = {
  updateVA: updatePositionVA1,  // читаем из position1
  tf: tf2,                      // записываем в position2
  drawVA: drawVA2,              // рисуем с position2
};
let next = {
  updateVA: updatePositionVA2,  // читаем из position2
  tf: tf1,                      // записываем в position1
  drawVA: drawVA1,              // рисуем с position1
};
</code></pre>
<p>Затем мы сделаем цикл рендеринга, сначала мы обновим позиции
используя transform feedback.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">let then = 0;
function render(time) {
  // конвертируем в секунды
  time *= 0.001;
  // Вычитаем предыдущее время из текущего времени
  const deltaTime = time - then;
  // Запоминаем текущее время для следующего кадра.
  then = time;

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  gl.clear(gl.COLOR_BUFFER_BIT);

  // вычисляем новые позиции
  gl.useProgram(updatePositionProgram);
  gl.bindVertexArray(current.updateVA);
  gl.uniform2f(updatePositionPrgLocs.canvasDimensions, gl.canvas.width, gl.canvas.height);
  gl.uniform1f(updatePositionPrgLocs.deltaTime, deltaTime);

  // отключаем использование фрагментного шейдера
  gl.enable(gl.RASTERIZER_DISCARD);

  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, current.tf);
  gl.beginTransformFeedback(gl.POINTS);
  gl.drawArrays(gl.POINTS, 0, numParticles);
  gl.endTransformFeedback();
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

  // включаем использование фрагментных шейдеров снова
  gl.disable(gl.RASTERIZER_DISCARD);
</code></pre>
<p>и затем рисуем частицы</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // теперь рисуем частицы.
  gl.useProgram(drawParticlesProgram);
  gl.bindVertexArray(current.drawVA);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.uniformMatrix4fv(
      drawParticlesProgLocs.matrix,
      false,
      m4.orthographic(0, gl.canvas.width, 0, gl.canvas.height, -1, 1));
  gl.drawArrays(gl.POINTS, 0, numParticles);
</code></pre>
<p>и наконец меняем местами <code class="notranslate" translate="no">current</code> и <code class="notranslate" translate="no">next</code>, чтобы на следующем кадре мы
использовали последние позиции для генерации новых</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // меняем местами, из какого буфера мы будем читать
  // и в какой мы будем записывать
  {
    const temp = current;
    current = next;
    next = temp;
  }

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</code></pre>
<p>И с этим у нас есть простые частицы на основе GPU.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-gpgpu-particles-transformfeedback.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-gpgpu-particles-transformfeedback.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<h2 id="следующий-пример-поиск-ближайшего-отрезка-линии-к-точке">Следующий пример: Поиск ближайшего отрезка линии к точке</h2>
<p>Я не уверен, что это хороший пример, но это тот, который я написал. Я говорю, что он может
быть нехорошим, потому что я подозреваю, что есть лучшие алгоритмы для поиска
ближайшей линии к точке, чем перебор проверки каждой линии с точкой. Например, различные алгоритмы пространственного разделения могут позволить вам легко отбросить 95%
точек и поэтому быть быстрее. Тем не менее, этот пример, вероятно, показывает
некоторые техники GPGPU по крайней мере.</p>
<p>Проблема: У нас есть 500 точек и 1000 отрезков линий. Для каждой точки
найти, какой отрезок линии к ней ближе всего. Метод перебора</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">for each point
  minDistanceSoFar = MAX_VALUE
  for each line segment
    compute distance from point to line segment
    if distance is &lt; minDistanceSoFar
       minDistanceSoFar = distance
       closestLine = line segment
</code></pre>
<p>Для 500 точек, каждая проверяющая 1000 линий, это 500,000 проверок.
Современные GPU имеют сотни или тысячи ядер, поэтому если мы могли бы сделать это на
GPU, мы могли бы потенциально работать в сотни или тысячи раз быстрее.</p>
<p>На этот раз, хотя мы можем поместить точки в буфер, как мы делали для частиц,
мы не можем поместить отрезки линий в буфер. Буферы предоставляют свои данные через
атрибуты. Это означает, что мы не можем случайно обращаться к любому значению по требованию, вместо
этого значения присваиваются атрибуту вне контроля шейдера.</p>
<p>Итак, нам нужно поместить позиции линий в текстуру, которая, как мы указали
выше, является другим словом для 2D массива, хотя мы все еще можем обращаться с этим 2D
массивом как с 1D массивом, если хотим.</p>
<p>Вот вершинный шейдер, который находит ближайшую линию для одной точки.
Это точно алгоритм перебора, как выше</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  const closestLineVS = `#version 300 es
  in vec3 point;

  uniform sampler2D linesTex;
  uniform int numLineSegments;

  flat out int closestNdx;

  vec4 getAs1D(sampler2D tex, ivec2 dimensions, int index) {
    int y = index / dimensions.x;
    int x = index % dimensions.x;
    return texelFetch(tex, ivec2(x, y), 0);
  }

  // из https://stackoverflow.com/a/6853926/128511
  // a - это точка, b,c - это отрезок линии
  float distanceFromPointToLine(in vec3 a, in vec3 b, in vec3 c) {
    vec3 ba = a - b;
    vec3 bc = c - b;
    float d = dot(ba, bc);
    float len = length(bc);
    float param = 0.0;
    if (len != 0.0) {
      param = clamp(d / (len * len), 0.0, 1.0);
    }
    vec3 r = b + bc * param;
    return distance(a, r);
  }

  void main() {
    ivec2 linesTexDimensions = textureSize(linesTex, 0);
    
    // находим ближайший отрезок линии
    float minDist = 10000000.0; 
    int minIndex = -1;
    for (int i = 0; i &lt; numLineSegments; ++i) {
      vec3 lineStart = getAs1D(linesTex, linesTexDimensions, i * 2).xyz;
      vec3 lineEnd = getAs1D(linesTex, linesTexDimensions, i * 2 + 1).xyz;
      float dist = distanceFromPointToLine(point, lineStart, lineEnd);
      if (dist &lt; minDist) {
        minDist = dist;
        minIndex = i;
      }
    }
    
    closestNdx = minIndex;
  }
  `;
</code></pre>
<p>Я переименовал <code class="notranslate" translate="no">getValueFrom2DTextureAs1DArray</code> в <code class="notranslate" translate="no">getAs1D</code> просто чтобы сделать
некоторые строки короче и более читаемыми.
В противном случае это довольно прямолинейная реализация алгоритма перебора,
который мы написали выше.</p>
<p><code class="notranslate" translate="no">point</code> - это текущая точка. <code class="notranslate" translate="no">linesTex</code> содержит точки для
отрезка линии парами, первая точка, за которой следует вторая точка.</p>
<p>Сначала давайте создадим некоторые тестовые данные. Вот 2 точки и 5 линий. Они
дополнены 0, 0, потому что каждая будет храниться в RGBA текстуре.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const points = [
  100, 100,
  200, 100,
];
const lines = [
   25,  50,
   25, 150,
   90,  50,
   90, 150,
  125,  50,
  125, 150,
  185,  50,
  185, 150,
  225,  50,
  225, 150,
];
const numPoints = points.length / 2;
const numLineSegments = lines.length / 2 / 2;
</code></pre>
<p>Если мы нанесем их на график, они будут выглядеть так</p>
<img src="../resources/line-segments-points.svg" style="width: 500px;" class="webgl_center">
<p>Линии пронумерованы от 0 до 4 слева направо,
поэтому если наш код работает, первая точка (<span style="color: red;">красная</span>)
должна получить значение 1 как ближайшая линия, вторая точка
(<span style="color: green;">зеленая</span>), должна получить значение 3.</p>
<p>Давайте поместим точки в буфер, а также создадим буфер для хранения вычисленного
ближайшего индекса для каждого</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const closestNdxBuffer = makeBuffer(gl, points.length * 4, gl.STATIC_DRAW);
const pointsBuffer = makeBuffer(gl, new Float32Array(points), gl.DYNAMIC_DRAW);
</code></pre>
<p>и давайте создадим текстуру для хранения всех конечных точек линий.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function createDataTexture(gl, data, numComponents, internalFormat, format, type) {
  const numElements = data.length / numComponents;

  // вычисляем размер, который будет содержать все наши данные
  const width = Math.ceil(Math.sqrt(numElements));
  const height = Math.ceil(numElements / width);

  const bin = new Float32Array(width * height * numComponents);
  bin.set(data);

  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(
      gl.TEXTURE_2D,
      0,        // mip level
      internalFormat,
      width,
      height,
      0,        // border
      format,
      type,
      bin,
  );
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return {tex, dimensions: [width, height]};
}

const {tex: linesTex, dimensions: linesTexDimensions} =
    createDataTexture(gl, lines, 2, gl.RG32F, gl.RG, gl.FLOAT);
</code></pre>
<p>В данном случае мы позволяем коду выбрать размеры текстуры
и позволяем ему дополнить текстуру. Например, если мы дадим ему массив
с 7 записями, он поместит это в текстуру 3x3. Он возвращает
и текстуру, и размеры, которые он выбрал. Почему мы позволяем ему выбрать
размер? Потому что текстуры имеют максимальный размер.</p>
<p>В идеале мы хотели бы просто смотреть на наши данные как на 1-мерный массив
позиций, 1-мерный массив точек линий и т.д. Поэтому мы могли бы просто
объявить текстуру как Nx1. К сожалению, GPU имеют максимальный
размер, и это может быть всего 1024 или 2048. Если лимит
был 1024 и нам нужно было 1025 значений в нашем массиве, нам пришлось бы поместить данные
в текстуру, скажем, 512x2. Помещая данные в квадрат, мы не
достигнем лимита, пока не достигнем максимального размера текстуры в квадрате.
Для лимита размера 1024 это позволило бы массивы более 1 миллиона значений.</p>
<p>Далее компилируем шейдер и находим локации</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const closestLinePrg = createProgram(
    gl, [closestLineVS, closestLineFS], ['closestNdx']);

const closestLinePrgLocs = {
  point: gl.getAttribLocation(closestLinePrg, 'point'),
  linesTex: gl.getUniformLocation(closestLinePrg, 'linesTex'),
  numLineSegments: gl.getUniformLocation(closestLinePrg, 'numLineSegments'),
};
</code></pre>
<p>И создаем вершинный массив</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const closestLineVA = makeVertexArray(gl, [
  [pointsBuffer, closestLinePrgLocs.point],
]);
</code></pre>
<p>И создаем transform feedback</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const closestLineTF = makeTransformFeedback(gl, closestNdxBuffer);
</code></pre>
<p>Теперь мы можем запустить вычисление</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.useProgram(closestLinePrg);
gl.bindVertexArray(closestLineVA);
gl.uniform1i(closestLinePrgLocs.linesTex, 0);
gl.uniform1f(closestLinePrgLocs.numLineSegments, numLineSegments);

gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, linesTex);

gl.enable(gl.RASTERIZER_DISCARD);
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, closestLineTF);
gl.beginTransformFeedback(gl.POINTS);
gl.drawArrays(gl.POINTS, 0, numPoints);
gl.endTransformFeedback();
gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
gl.disable(gl.RASTERIZER_DISCARD);
</code></pre>
<p>И читаем результаты</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const results = new Int32Array(numPoints);
gl.bindBuffer(gl.ARRAY_BUFFER, closestNdxBuffer);
gl.getBufferSubData(gl.ARRAY_BUFFER, 0, results);
console.log('results:', results);
</code></pre>
<p>Результаты должны быть <code class="notranslate" translate="no">[1, 3]</code>, что означает, что точка 0 ближе всего к линии 1,
а точка 1 ближе всего к линии 3.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-gpgpu-closest-line-results-transformfeedback.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-gpgpu-closest-line-results-transformfeedback.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<h2 id="следующий-пример-динамический-transform-feedback">Следующий пример: Динамический transform feedback</h2>
<p>В предыдущем примере мы использовали transform feedback для записи результатов
в буфер. Но что, если мы хотим использовать эти результаты в следующем кадре?</p>
<p>Вот пример, где мы используем transform feedback для создания анимации.
Мы создаем частицы, которые движутся по кругу, и используем transform feedback
для обновления их позиций каждый кадр.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const vs = `#version 300 es
in vec4 position;
in vec4 velocity;
in float age;

uniform float u_time;
uniform float u_deltaTime;

out vec4 v_position;
out vec4 v_velocity;
out float v_age;

void main() {
  v_position = position;
  v_velocity = velocity;
  v_age = age;
}
`;

const fs = `#version 300 es
precision highp float;

in vec4 v_position;
in vec4 v_velocity;
in float v_age;

uniform float u_time;
uniform float u_deltaTime;

out vec4 outColor;

void main() {
  // обновляем позицию
  vec4 newPosition = v_position + v_velocity * u_deltaTime;
  
  // обновляем скорость (добавляем небольшое ускорение)
  vec4 newVelocity = v_velocity + vec4(0.0, -9.8, 0.0, 0.0) * u_deltaTime;
  
  // увеличиваем возраст
  float newAge = v_age + u_deltaTime;
  
  // если частица слишком старая, сбрасываем её
  if (newAge &gt; 5.0) {
    newPosition = vec4(0.0, 0.0, 0.0, 1.0);
    newVelocity = vec4(
      sin(u_time + gl_FragCoord.x * 0.01) * 100.0,
      cos(u_time + gl_FragCoord.y * 0.01) * 100.0,
      0.0, 0.0
    );
    newAge = 0.0;
  }
  
  outColor = vec4(newPosition.xyz, newAge);
}
`;

const numParticles = 1000;
const positions = new Float32Array(numParticles * 4);
const velocities = new Float32Array(numParticles * 4);
const ages = new Float32Array(numParticles);

// инициализируем частицы
for (let i = 0; i &lt; numParticles; ++i) {
  const angle = (i / numParticles) * Math.PI * 2;
  const radius = 100 + Math.random() * 50;
  
  positions[i * 4 + 0] = Math.cos(angle) * radius;
  positions[i * 4 + 1] = Math.sin(angle) * radius;
  positions[i * 4 + 2] = 0;
  positions[i * 4 + 3] = 1;
  
  velocities[i * 4 + 0] = Math.cos(angle) * 50;
  velocities[i * 4 + 1] = Math.sin(angle) * 50;
  velocities[i * 4 + 2] = 0;
  velocities[i * 4 + 3] = 0;
  
  ages[i] = Math.random() * 5;
}

const positionBuffer = makeBuffer(gl, positions, gl.DYNAMIC_DRAW);
const velocityBuffer = makeBuffer(gl, velocities, gl.DYNAMIC_DRAW);
const ageBuffer = makeBuffer(gl, ages, gl.DYNAMIC_DRAW);

const updateProgram = createProgram(gl, [vs, fs], ['v_position', 'v_velocity', 'v_age']);

const updateProgramLocs = {
  position: gl.getAttribLocation(updateProgram, 'position'),
  velocity: gl.getAttribLocation(updateProgram, 'velocity'),
  age: gl.getAttribLocation(updateProgram, 'age'),
  time: gl.getUniformLocation(updateProgram, 'u_time'),
  deltaTime: gl.getUniformLocation(updateProgram, 'u_deltaTime'),
};

const updateVA = makeVertexArray(gl, [
  [positionBuffer, updateProgramLocs.position],
  [velocityBuffer, updateProgramLocs.velocity],
  [ageBuffer, updateProgramLocs.age],
]);

const updateTF = makeTransformFeedback(gl, positionBuffer);

let then = 0;
function render(time) {
  time *= 0.001;
  const deltaTime = time - then;
  then = time;

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // обновляем частицы
  gl.useProgram(updateProgram);
  gl.bindVertexArray(updateVA);
  gl.uniform1f(updateProgramLocs.time, time);
  gl.uniform1f(updateProgramLocs.deltaTime, deltaTime);

  gl.enable(gl.RASTERIZER_DISCARD);
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, updateTF);
  gl.beginTransformFeedback(gl.POINTS);
  gl.drawArrays(gl.POINTS, 0, numParticles);
  gl.endTransformFeedback();
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  gl.disable(gl.RASTERIZER_DISCARD);

  // рисуем частицы
  gl.useProgram(drawProgram);
  gl.bindVertexArray(drawVA);
  gl.uniformMatrix4fv(
      drawProgramLocs.matrix,
      false,
      m4.orthographic(-gl.canvas.width/2, gl.canvas.width/2, 
                      -gl.canvas.height/2, gl.canvas.height/2, -1, 1));
  gl.drawArrays(gl.POINTS, 0, numParticles);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</code></pre>
<h2 id="следующий-пример-визуализация-результатов">Следующий пример: Визуализация результатов</h2>
<p>В предыдущем примере мы вычислили, какая линия ближе всего к каждой точке,
но мы только вывели результаты в консоль. Давайте создадим визуализацию,
которая покажет точки, линии и соединит каждую точку с ближайшей к ней линией.</p>
<p>Сначала нам нужны шейдеры для рисования линий и точек:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const drawLinesVS = `#version 300 es
in vec4 position;
void main() {
  gl_Position = position;
}
`;

const drawLinesFS = `#version 300 es
precision highp float;
out vec4 outColor;
void main() {
  outColor = vec4(0.5, 0.5, 0.5, 1);  // серый цвет для всех линий
}
`;

const drawClosestLinesVS = `#version 300 es
in int closestNdx;

uniform sampler2D linesTex;
uniform mat4 matrix;
uniform float numPoints;

out vec4 v_color;

vec3 hsv2rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
  // получаем координаты линии из текстуры
  ivec2 texelCoord = ivec2(closestNdx, 0);
  vec4 lineData = texelFetch(linesTex, texelCoord, 0);
  
  // выбираем начальную или конечную точку линии
  int linePointId = closestNdx * 2 + gl_VertexID % 2;
  vec2 linePoint = mix(lineData.xy, lineData.zw, gl_VertexID % 2);
  
  gl_Position = matrix * vec4(linePoint, 0, 1);
  
  // вычисляем цвет на основе ID точки
  float hue = float(gl_InstanceID) / numPoints;
  v_color = vec4(hsv2rgb(vec3(hue, 1, 1)), 1);
}
`;

const drawClosestLinesPointsFS = `#version 300 es
precision highp float;
in vec4 v_color;
out vec4 outColor;
void main() {
  outColor = v_color;
}
`;

const drawPointsVS = `#version 300 es
in vec2 point;

uniform mat4 matrix;
uniform float numPoints;

out vec4 v_color;

vec3 hsv2rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main() {
  gl_Position = matrix * vec4(point, 0, 1);
  gl_PointSize = 10.0;
  
  // вычисляем цвет на основе ID точки
  float hue = float(gl_VertexID) / numPoints;
  v_color = vec4(hsv2rgb(vec3(hue, 1, 1)), 1);
}
`;
</code></pre>
<p>Мы передаем <code class="notranslate" translate="no">closestNdx</code> как атрибут. Это результаты, которые мы сгенерировали.
Используя это, мы можем найти конкретную линию. Нам нужно нарисовать 2 точки на линию,
поэтому мы будем использовать <a href="webgl-instanced-drawing.html">инстансированное рисование</a>
для рисования 2 точек на <code class="notranslate" translate="no">closestNdx</code>. Затем мы можем использовать <code class="notranslate" translate="no">gl_VertexID % 2</code>
для выбора начальной или конечной точки.</p>
<p>Наконец, мы вычисляем цвет, используя тот же метод, который мы использовали при рисовании точек,
чтобы они соответствовали своим точкам.</p>
<p>Нам нужно скомпилировать все эти новые программы шейдеров и найти местоположения:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const closestLinePrg = createProgram(
    gl, [closestLineVS, closestLineFS], ['closestNdx']);
const drawLinesPrg = createProgram(
    gl, [drawLinesVS, drawLinesFS]);
const drawClosestLinesPrg = createProgram(
    gl, [drawClosestLinesVS, drawClosestLinesPointsFS]);
const drawPointsPrg = createProgram(
    gl, [drawPointsVS, drawClosestLinesPointsFS]);

const closestLinePrgLocs = {
  point: gl.getAttribLocation(closestLinePrg, 'point'),
  linesTex: gl.getUniformLocation(closestLinePrg, 'linesTex'),
  numLineSegments: gl.getUniformLocation(closestLinePrg, 'numLineSegments'),
};
const drawLinesPrgLocs = {
  linesTex: gl.getUniformLocation(drawLinesPrg, 'linesTex'),
  matrix: gl.getUniformLocation(drawLinesPrg, 'matrix'),
};
const drawClosestLinesPrgLocs = {
  closestNdx: gl.getAttribLocation(drawClosestLinesPrg, 'closestNdx'),
  linesTex: gl.getUniformLocation(drawClosestLinesPrg, 'linesTex'),
  matrix: gl.getUniformLocation(drawClosestLinesPrg, 'matrix'),
  numPoints: gl.getUniformLocation(drawClosestLinesPrg, 'numPoints'),
};
const drawPointsPrgLocs = {
  point: gl.getAttribLocation(drawPointsPrg, 'point'),
  matrix: gl.getUniformLocation(drawPointsPrg, 'matrix'),
  numPoints: gl.getUniformLocation(drawPointsPrg, 'numPoints'),
};
</code></pre>
<p>Нам нужны массивы вершин для рисования точек и ближайших линий:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const closestLinesVA = makeVertexArray(gl, [
  [pointsBuffer, closestLinePrgLocs.point],
]);

const drawClosestLinesVA = gl.createVertexArray();
gl.bindVertexArray(drawClosestLinesVA);
gl.bindBuffer(gl.ARRAY_BUFFER, closestNdxBuffer);
gl.enableVertexAttribArray(drawClosestLinesPrgLocs.closestNdx);
gl.vertexAttribIPointer(drawClosestLinesPrgLocs.closestNdx, 1, gl.INT, 0, 0);
gl.vertexAttribDivisor(drawClosestLinesPrgLocs.closestNdx, 1);

const drawPointsVA = makeVertexArray(gl, [
  [pointsBuffer, drawPointsPrgLocs.point],
]);
</code></pre>
<p>Итак, во время рендеринга мы вычисляем результаты, как мы делали раньше, но
мы не ищем результаты с помощью <code class="notranslate" translate="no">getBufferSubData</code>. Вместо этого мы просто
передаем их в соответствующие шейдеры.</p>
<p>Сначала рисуем все линии серым цветом:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// рисуем все линии серым цветом
gl.bindFramebuffer(gl.FRAMEBUFFER, null);
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

gl.bindVertexArray(null);
gl.useProgram(drawLinesPrg);

// привязываем текстуру линий к текстуре unit 0
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, linesTex);

// Говорим шейдеру использовать текстуру на текстуре unit 0
gl.uniform1i(drawLinesPrgLocs.linesTex, 0);
gl.uniformMatrix4fv(drawLinesPrgLocs.matrix, false, matrix);

gl.drawArrays(gl.LINES, 0, numLineSegments * 2);
</code></pre>
<p>Затем рисуем все ближайшие линии:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.bindVertexArray(drawClosestLinesVA);
gl.useProgram(drawClosestLinesPrg);

gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, linesTex);

gl.uniform1i(drawClosestLinesPrgLocs.linesTex, 0);
gl.uniform1f(drawClosestLinesPrgLocs.numPoints, numPoints);
gl.uniformMatrix4fv(drawClosestLinesPrgLocs.matrix, false, matrix);

gl.drawArraysInstanced(gl.LINES, 0, 2, numPoints);
</code></pre>
<p>и наконец рисуем каждую точку:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">gl.bindVertexArray(drawPointsVA);
gl.useProgram(drawPointsPrg);

gl.uniform1f(drawPointsPrgLocs.numPoints, numPoints);
gl.uniformMatrix4fv(drawPointsPrgLocs.matrix, false, matrix);

gl.drawArrays(gl.POINTS, 0, numPoints);
</code></pre>
<p>Прежде чем запустить, давайте сделаем еще одну вещь. Добавим больше точек и линий:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function createPoints(numPoints, ranges) {
  const points = [];
  for (let i = 0; i &lt; numPoints; ++i) {
    points.push(...ranges.map(range =&gt; r(...range)));
  }
  return points;
}

const r = (min, max) =&gt; min + Math.random() * (max - min);

const points = createPoints(8, [[0, gl.canvas.width], [0, gl.canvas.height]]);
const lines = createPoints(125 * 2, [[0, gl.canvas.width], [0, gl.canvas.height]]);
const numPoints = points.length / 2;
const numLineSegments = lines.length / 2 / 2;
</code></pre>
<p>и если мы запустим это:</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-gpgpu-closest-line-transformfeedback.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-gpgpu-closest-line-transformfeedback.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Вы можете увеличить количество точек и линий,
но в какой-то момент вы не сможете сказать, какие
точки соответствуют каким линиям, но с меньшим числом
вы можете хотя бы визуально проверить, что это работает.</p>
<p>Просто для удовольствия, давайте объединим пример с частицами и этот
пример. Мы будем использовать техники, которые мы использовали для обновления
позиций частиц, чтобы обновить точки. Для
обновления конечных точек линий мы сделаем то, что мы делали в
начале, и запишем результаты в текстуру.</p>
<p>Для этого мы копируем <code class="notranslate" translate="no">updatePositionFS</code> вершинный шейдер
из примера с частицами. Для линий, поскольку их значения
хранятся в текстуре, нам нужно переместить их точки в
фрагментном шейдере:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const updateLinesVS = `#version 300 es
in vec4 position;
void main() {
  gl_Position = position;
}
`;

const updateLinesFS = `#version 300 es
precision highp float;

uniform sampler2D linesTex;
uniform sampler2D velocityTex;
uniform vec2 canvasDimensions;
uniform float deltaTime;

out vec4 outColor;

vec2 euclideanModulo(vec2 n, vec2 m) {
	return mod(mod(n, m) + m, m);
}

void main() {
  // вычисляем координаты текселя из gl_FragCoord;
  ivec2 texelCoord = ivec2(gl_FragCoord.xy);
  
  // получаем данные линии
  vec4 lineData = texelFetch(linesTex, texelCoord, 0);
  
  // получаем скорость для этой линии
  vec2 velocity = texelFetch(velocityTex, texelCoord, 0).xy;
  
  // обновляем позиции
  vec2 newStart = euclideanModulo(lineData.xy + velocity * deltaTime, canvasDimensions);
  vec2 newEnd = euclideanModulo(lineData.zw + velocity * deltaTime, canvasDimensions);
  
  outColor = vec4(newStart, newEnd);
}
`;
</code></pre>
<p>Теперь нам нужны буферы для хранения скоростей линий и программа для их обновления:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const lineVelocities = new Float32Array(numLineSegments * 2);
for (let i = 0; i &lt; numLineSegments; ++i) {
  lineVelocities[i * 2 + 0] = (Math.random() - 0.5) * 100;
  lineVelocities[i * 2 + 1] = (Math.random() - 0.5) * 100;
}

const lineVelocityBuffer = makeBuffer(gl, lineVelocities, gl.DYNAMIC_DRAW);
const lineVelocityTex = makeDataTexture(gl, lineVelocities, numLineSegments, 1);

const updateLinesPrg = createProgram(gl, [updateLinesVS, updateLinesFS]);

const updateLinesPrgLocs = {
  linesTex: gl.getUniformLocation(updateLinesPrg, 'linesTex'),
  velocityTex: gl.getUniformLocation(updateLinesPrg, 'velocityTex'),
  canvasDimensions: gl.getUniformLocation(updateLinesPrg, 'canvasDimensions'),
  deltaTime: gl.getUniformLocation(updateLinesPrg, 'deltaTime'),
};
</code></pre>
<p>Теперь в нашем цикле рендеринга мы обновляем линии, затем точки, затем рисуем все:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function render(time) {
  time *= 0.001;
  const deltaTime = time - then;
  then = time;

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // обновляем линии
  gl.bindFramebuffer(gl.FRAMEBUFFER, linesFramebuffer);
  gl.viewport(0, 0, numLineSegments, 1);
  
  gl.useProgram(updateLinesPrg);
  gl.bindVertexArray(null);
  
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, linesTex);
  gl.uniform1i(updateLinesPrgLocs.linesTex, 0);
  
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, lineVelocityTex);
  gl.uniform1i(updateLinesPrgLocs.velocityTex, 1);
  
  gl.uniform2f(updateLinesPrgLocs.canvasDimensions, gl.canvas.width, gl.canvas.height);
  gl.uniform1f(updateLinesPrgLocs.deltaTime, deltaTime);
  
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  // обновляем точки
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  
  gl.useProgram(updateProgram);
  gl.bindVertexArray(updateVA);
  gl.uniform1f(updateProgramLocs.time, time);
  gl.uniform1f(updateProgramLocs.deltaTime, deltaTime);

  gl.enable(gl.RASTERIZER_DISCARD);
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, updateTF);
  gl.beginTransformFeedback(gl.POINTS);
  gl.drawArrays(gl.POINTS, 0, numPoints);
  gl.endTransformFeedback();
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  gl.disable(gl.RASTERIZER_DISCARD);

  // вычисляем ближайшие линии
  gl.bindFramebuffer(gl.FRAMEBUFFER, closestLineFramebuffer);
  gl.viewport(0, 0, numPoints, 1);
  
  gl.useProgram(closestLinePrg);
  gl.bindVertexArray(closestLinesVA);
  gl.uniform1i(closestLinePrgLocs.linesTex, 0);
  gl.uniform1f(closestLinePrgLocs.numLineSegments, numLineSegments);
  
  gl.enable(gl.RASTERIZER_DISCARD);
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, closestLineTF);
  gl.beginTransformFeedback(gl.POINTS);
  gl.drawArrays(gl.POINTS, 0, numPoints);
  gl.endTransformFeedback();
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  gl.disable(gl.RASTERIZER_DISCARD);

  // рисуем все
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // рисуем все линии серым цветом
  gl.bindVertexArray(null);
  gl.useProgram(drawLinesPrg);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, linesTex);
  gl.uniform1i(drawLinesPrgLocs.linesTex, 0);
  gl.uniformMatrix4fv(drawLinesPrgLocs.matrix, false, matrix);
  gl.drawArrays(gl.LINES, 0, numLineSegments * 2);

  // рисуем ближайшие линии
  gl.bindVertexArray(drawClosestLinesVA);
  gl.useProgram(drawClosestLinesPrg);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, linesTex);
  gl.uniform1i(drawClosestLinesPrgLocs.linesTex, 0);
  gl.uniform1f(drawClosestLinesPrgLocs.numPoints, numPoints);
  gl.uniformMatrix4fv(drawClosestLinesPrgLocs.matrix, false, matrix);
  gl.drawArraysInstanced(gl.LINES, 0, 2, numPoints);

  // рисуем точки
  gl.bindVertexArray(drawPointsVA);
  gl.useProgram(drawPointsPrg);
  gl.uniform1f(drawPointsPrgLocs.numPoints, numPoints);
  gl.uniformMatrix4fv(drawPointsPrgLocs.matrix, false, matrix);
  gl.drawArrays(gl.POINTS, 0, numPoints);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-gpgpu-closest-line-dynamic-transformfeedback.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-gpgpu-closest-line-dynamic-transformfeedback.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<h2 id="важные-замечания">Важные замечания</h2>
<ul>
<li>
<p>GPGPU в WebGL1 в основном ограничен использованием 2D массивов в качестве вывода (текстуры).
WebGL2 добавляет возможность просто обрабатывать 1D массив произвольного размера через
transform feedback.</p>
<p>Если вам интересно, посмотрите <a href="https://webglfundamentals.org/webgl/lessons/webgl-gpgpu.html">ту же статью для webgl1</a>, чтобы увидеть, как все это было сделано, используя только возможность
вывода в текстуры. Конечно, с небольшим размышлением это должно быть очевидно.</p>
<p>Версии WebGL2, использующие текстуры вместо transform feedback, также доступны,
поскольку использование <code class="notranslate" translate="no">texelFetch</code> и наличие большего количества форматов текстур немного изменяет
их реализации.</p>
<ul>
<li><a href="../../webgl-gpgpu-particles.html">частицы</a></li>
<li><a href="../../webgl-gpgpu-closest-line-results.html">результаты ближайших линий</a></li>
<li><a href="../../webgl-gpgpu-closest-line.html">визуализация ближайших линий</a></li>
<li><a href="../../webgl-gpgpu-closest-line-dynamic.html">динамические ближайшие линии</a></li>
</ul>
</li>
<li>
<p>Ошибка Firefox<a id="firefox-bug"></a></p>
<p>Firefox начиная с версии 84 имеет <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1677552">ошибку</a> в том,
что он неправильно требует наличия по крайней мере одного активного атрибута, который использует делитель 0 при вызове
<code class="notranslate" translate="no">drawArraysIndexed</code>. Это означает, что пример выше, где мы рисуем ближайшие линии, используя
<code class="notranslate" translate="no">drawArraysIndexed</code>, не работает.</p>
<p>Чтобы обойти это, мы можем создать буфер, который просто содержит <code class="notranslate" translate="no">[0, 1]</code> в нем, и использовать его
на атрибуте для того, как мы использовали <code class="notranslate" translate="no">gl_VertexID % 2</code>. Вместо этого мы будем использовать</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">in int endPoint;  // нужно для firefox

...
-int linePointId = closestNdx * 2 + gl_VertexID % 2;
+int linePointId = closestNdx * 2 + endPoint;
...
</code></pre>
<p>что <a href="../../webgl/webgl-gpgpu-closest-line-dynamic-transformfeedback-ff.html">сделает это работающим в firefox</a>.</p>
</li>
<li>
<p>GPU не имеют той же точности, что и CPU.</p>
<p>Проверьте ваши результаты и убедитесь, что они приемлемы.</p>
</li>
<li>
<p>Есть накладные расходы на GPGPU.</p>
<p>В первых нескольких примерах выше мы вычислили некоторые
данные, используя WebGL, а затем прочитали результаты. Настройка буферов и текстур,
установка атрибутов и uniform переменных занимает время. Достаточно времени, чтобы для чего-либо
меньше определенного размера было бы лучше просто сделать это в JavaScript.
Фактические примеры умножения 6 чисел или сложения 3 пар чисел
слишком малы для того, чтобы GPGPU был полезен. Где находится эта граница
не определено. Экспериментируйте, но просто догадка, что если вы не делаете по крайней мере
1000 или больше вещей, оставьте это в JavaScript.</p>
</li>
<li>
<p><code class="notranslate" translate="no">readPixels</code> и <code class="notranslate" translate="no">getBufferSubData</code> медленные</p>
<p>Чтение результатов из WebGL медленное, поэтому важно избегать этого
как можно больше. В качестве примера ни система частиц выше, ни
пример динамических ближайших линий никогда
не читают результаты обратно в JavaScript. Где можете, держите результаты
на GPU как можно дольше. Другими словами, вы могли бы сделать что-то
вроде</p>
<ul>
<li>вычисляем что-то на GPU</li>
<li>читаем результат</li>
<li>подготавливаем результат для следующего шага</li>
<li>загружаем подготовленный результат на GPU</li>
<li>вычисляем что-то на GPU</li>
<li>читаем результат</li>
<li>подготавливаем результат для следующего шага</li>
<li>загружаем подготовленный результат на GPU</li>
<li>вычисляем что-то на GPU</li>
<li>читаем результат</li>
</ul>
<p>тогда как через творческие решения было бы намного быстрее, если бы вы могли</p>
<ul>
<li>вычисляем что-то на GPU</li>
<li>подготавливаем результат для следующего шага, используя GPU</li>
<li>вычисляем что-то на GPU</li>
<li>подготавливаем результат для следующего шага, используя GPU</li>
<li>вычисляем что-то на GPU</li>
<li>читаем результат</li>
</ul>
<p>Наш пример динамических ближайших линий делал это. Результаты никогда не покидают
GPU.</p>
<p>В качестве другого примера я однажды написал шейдер для вычисления гистограммы. Затем я прочитал
результаты обратно в JavaScript, вычислил минимальные и максимальные значения,
затем нарисовал изображение обратно на canvas, используя эти минимальные и максимальные значения
как uniform переменные для автоматического выравнивания изображения.</p>
<p>Но оказалось, что вместо чтения гистограммы обратно в JavaScript
я мог вместо этого запустить шейдер на самой гистограмме, который генерировал
2-пиксельную текстуру с минимальными и максимальными значениями в текстуре.</p>
<p>Я мог затем передать эту 2-пиксельную текстуру в 3-й шейдер, который
мог читать для минимальных и максимальных значений. Нет необходимости читать их из
GPU для установки uniform переменных.</p>
<p>Аналогично для отображения самой гистограммы я сначала читал данные гистограммы
из GPU, но позже я вместо этого написал шейдер, который мог
визуализировать данные гистограммы напрямую, убрав необходимость читать их
обратно в JavaScript.</p>
<p>Делая это, весь процесс оставался на GPU и, вероятно, был намного
быстрее.</p>
</li>
<li>
<p>GPU могут делать много вещей параллельно, но большинство не могут многозадачно так же, как
CPU может. GPU обычно не могут делать “<a href="https://www.google.com/search?q=preemptive+multitasking">вытесняющую многозадачность</a>”.
Это означает, что если вы дадите им очень сложный шейдер, который, скажем, занимает 5 минут для
выполнения, они потенциально заморозят всю вашу машину на 5 минут.
Большинство хорошо сделанных ОС справляются с этим, заставляя CPU проверять, сколько времени прошло
с тех пор, как они дали последнюю команду GPU. Если прошло слишком много времени (5-6 секунд)
и GPU не ответил, то их единственный вариант - сбросить GPU.</p>
<p>Это одна из причин, почему WebGL может <em>потерять контекст</em> и вы получите сообщение “Aw, rats!”
или подобное.</p>
<p>Легко дать GPU слишком много работы, но в графике это не <em>так</em>
часто доводить до уровня 5-6 секунд. Обычно это больше похоже на уровень 0.1
секунды, что все еще плохо, но обычно вы хотите, чтобы графика работала быстро
и поэтому программист, надеюсь, оптимизирует или найдет другую технику
для поддержания отзывчивости их приложения.</p>
<p>GPGPU, с другой стороны, вы можете действительно захотеть дать GPU тяжелую задачу
для выполнения. Здесь нет простого решения. Мобильный телефон имеет гораздо менее мощный
GPU, чем топовый ПК. Помимо собственного тайминга, нет способа
точно знать, сколько работы вы можете дать GPU, прежде чем это “слишком медленно”</p>
<p>У меня нет решения для предложения. Только предупреждение, что в зависимости от того, что вы
пытаетесь сделать, вы можете столкнуться с этой проблемой.</p>
</li>
<li>
<p>Мобильные устройства обычно не поддерживают рендеринг в текстуры с плавающей точкой</p>
<p>Есть различные способы обойти эту проблему. Один из способов - вы можете
использовать функции GLSL <code class="notranslate" translate="no">floatBitsToInt</code>, <code class="notranslate" translate="no">floatBitsToUint</code>, <code class="notranslate" translate="no">IntBitsToFloat</code>,
и <code class="notranslate" translate="no">UintBitsToFloat</code>.</p>
<p>В качестве примера, <a href="../../webgl-gpgpu-particles.html">версия на основе текстур примера с частицами</a>
должна записывать в текстуры с плавающей точкой. Мы могли бы исправить это так, чтобы это не требовало их, объявив
нашу текстуру как тип <code class="notranslate" translate="no">RG32I</code> (32-битные целочисленные текстуры), но все еще
загружать float значения.</p>
<p>В шейдере нам нужно будет читать текстуры как целые числа и декодировать их
в float, а затем кодировать результат обратно в целые числа. Например:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
precision highp float;

-uniform highp sampler2D positionTex;
-uniform highp sampler2D velocityTex;
+uniform highp isampler2D positionTex;
+uniform highp isampler2D velocityTex;
uniform vec2 canvasDimensions;
uniform float deltaTime;

out ivec4 outColor;

vec2 euclideanModulo(vec2 n, vec2 m) {
	return mod(mod(n, m) + m, m);
}

void main() {
  // будет одна скорость на позицию
  // поэтому текстура скорости и текстура позиции
  // имеют одинаковый размер.

  // кроме того, мы генерируем новые позиции
  // поэтому мы знаем, что наше назначение того же размера
  // что и наш источник

  // вычисляем координаты текстуры из gl_FragCoord;
  ivec2 texelCoord = ivec2(gl_FragCoord.xy);
  
-  vec2 position = texelFetch(positionTex, texelCoord, 0).xy;
-  vec2 velocity = texelFetch(velocityTex, texelCoord, 0).xy;
+  vec2 position = intBitsToFloat(texelFetch(positionTex, texelCoord, 0).xy);
+  vec2 velocity = intBitsToFloat(texelFetch(velocityTex, texelCoord, 0).xy);
  vec2 newPosition = euclideanModulo(position + velocity * deltaTime, canvasDimensions);

-  outColor = vec4(newPosition, 0, 1);
+  outColor = ivec4(floatBitsToInt(newPosition), 0, 1);
}
</code></pre>
<p><a href="../../webgl-gpgpu-particles-no-floating-point-textures.html">Вот рабочий пример</a></p>
</li>
</ul>
<p>Я надеюсь, что эти примеры помогли вам понять ключевую идею GPGPU в WebGL</p>
<ul>
<li>это просто тот факт, что WebGL читает из и записывает в массивы <strong>данных</strong>,
а не пикселей.</li>
</ul>
<p>Шейдеры работают аналогично функциям <code class="notranslate" translate="no">map</code> в том, что функция, которая вызывается
для каждого значения, не может решить, где будет храниться ее значение.
Скорее это решается извне функции. В случае WebGL
это решается тем, как вы настраиваете то, что рисуете. Как только вы вызываете <code class="notranslate" translate="no">gl.drawXXX</code>
шейдер будет вызван для каждого нужного значения с вопросом “какое значение я должен
сделать этим?”</p>
<p>И это действительно все.</p>
<hr>
<p>Поскольку мы создали некоторые частицы через GPGPU, есть <a href="https://www.youtube.com/watch?v=X-iSQQgOd1A">это замечательное видео</a>, которое во второй половине
использует compute шейдеры для симуляции “слизи”.</p>
<p>Используя техники выше <a href="https://jsgist.org/?src=94e9058c7ef1a4f124eccab4e7fdcd1d">вот это переведено в WebGL2</a>.</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-gpgpu.html" >English</a>
    <option value="/webgl/lessons/de/webgl-gpgpu.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-gpgpu.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-gpgpu.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-gpgpu.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-gpgpu.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-gpgpu.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-getting-webgl2.html">Как использовать WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как это работает</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 Диаграмма состояния</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl2-whats-new.html">Что нового в WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2.html">Переход с WebGL1 на WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2-fundamentals.html">Отличия от WebGLFundamentals.org до WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продвинутая обработка изображений</a></li>
        </ul>
  <li>2D трансформации, повороты, масштабирование и матричные операции</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D Трансляция</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D Вращение</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D Масштабирование</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D Матрицы</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">Ортографическая 3D</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">3D Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">3D - Камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-naming.html">3D - Именование матриц</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
        </ul>
  <li>Организация и рефакторинг</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">Меньше кода, больше удовольствия</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">Рисование множественных объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">Графы сцен</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">3D Геометрия - Токарная обработка</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Загрузка .obj файлов</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Загрузка .obj с .mtl файлами</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">Использование 2 или более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">Перспективно-корректное наложение текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Планарное и перспективное проекционное отображение</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
        </ul>
  <li>Тени</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Тени</a></li>
        </ul>
  <li>Техники</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">2D - Стек Матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Спрайты</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Кубические карты</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Карты окружения</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Скайбоксы</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Скининг</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Выбор объектов (клик по объектам)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">Текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">Текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">Текст - Использование текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">Текст - Использование текстуры глифов</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Самые маленькие программы</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Рисование без данных</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Вытягивание вершин</a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Индексированные вершины (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Инстансинг (Instanced Drawing)</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">Настройка и установка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Точки, линии и треугольники</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Множественные виды, множественные canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL2 и альфа-канал</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">2D против 3D библиотек</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">Анти-паттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL2 Матрицы против математических матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Проблемы точности</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Скриншот канваса</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Как не очищать канвас</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Получение ввода с клавиатуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Использование WebGL2 как фона в HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Справочник</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Атрибуты</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Текстурные юниты</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">Ссылки</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API документация</a></li>
  <li><a href="https://twgljs.org">TWGL, легковесная библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Есть предложения или замечания? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Создайте issue на GitHub</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 GPGPU';
            var disqus_title = 'WebGL2 GPGPU';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Спасибо <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>за <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} вкладов</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



