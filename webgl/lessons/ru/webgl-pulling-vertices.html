<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/ru/webgl-pulling-vertices.md. Do not edited directly -->
<!--
Copyright 2021, GFXFundamentals.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of GFXFundamentals. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Использование независимых индексов">
<meta name="keywords" content="webgl webgl2 graphics">
<meta name="thumbnail" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-pulling-vertices_ru.jpg">

<meta property="og:title" content="WebGL2 Вытягивание вершин">
<meta property="og:type" content="website">
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-pulling-vertices_ru.jpg">
<meta property="og:description" content="Использование независимых индексов">
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-pulling-vertices.html">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@greggman">
<meta name="twitter:creator" content="@greggman">
<meta name="twitter:domain" content="webgl2fundamentals.org">
<meta name="twitter:title" content="WebGL2 Вытягивание вершин">
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/ru/webgl-pulling-vertices.html">
<meta name="twitter:description" content="Использование независимых индексов">
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-pulling-vertices_ru.jpg">

<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"WebSite",
      "@id":"https://webgl2fundamentals.org/#website",
      "url":"https://webgl2fundamentals.org/",
      "name":"Webgl2Fundamentals"
    },
    {
      "@type":"ImageObject",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-pulling-vertices.html#primaryimage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/screenshots/webgl-pulling-vertices_ru.jpg",
      "width":1200,
      "height":630
    },
    {
      "@type":"WebPage",
      "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-pulling-vertices.html#webpage",
      "url":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-pulling-vertices.html",
      "inLanguage":"ru",
      "name":"WebGL2 Вытягивание вершин",
      "keywords":"webgl webgl2 graphics programming",
      "isPartOf":{
        "@id":"https://webgl2fundamentals.org/#website"
      },
      "primaryImageOfPage":{
        "@id":"https://webgl2fundamentals.org/webgl/lessons/ru/webgl-pulling-vertices.html#primaryimage"
      }
    }
  ]
}
</script>


<title>WebGL2 Вытягивание вершин</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/lang.css">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css">

  <link rel="alternate" hreflang="en" href="https://webglfundamentals.org/webgl/lessons/webgl-pulling-vertices.html">
  <link rel="alternate" hreflang="de" href="https://webglfundamentals.org/webgl/lessons/de/webgl-pulling-vertices.html">
  <link rel="alternate" hreflang="ja" href="https://webglfundamentals.org/webgl/lessons/ja/webgl-pulling-vertices.html">
  <link rel="alternate" hreflang="ko" href="https://webglfundamentals.org/webgl/lessons/ko/webgl-pulling-vertices.html">
  <link rel="alternate" hreflang="pt-br" href="https://webglfundamentals.org/webgl/lessons/pt-br/webgl-pulling-vertices.html">
  <link rel="alternate" hreflang="ru" href="https://webglfundamentals.org/webgl/lessons/ru/webgl-pulling-vertices.html">
  <link rel="alternate" hreflang="zh_cn" href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-pulling-vertices.html">




</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-pulling-vertices.html" >English</a>
    <option value="/webgl/lessons/de/webgl-pulling-vertices.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-pulling-vertices.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-pulling-vertices.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-pulling-vertices.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-pulling-vertices.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-pulling-vertices.html" >简体中文</a>
</select>


    <a href="#toc">Содержание</a>
    <input type="search" placeholder="?" id="search">
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/ru/">WebGL2Fundamentals.org</a></h1>
<style>
#forkongithub>div {
    background: #000;
    color: #fff;
    font-family: arial,sans-serif;
    text-align: center;
    font-weight: bold;
    padding: 5px 40px;
    font-size: 0.9rem;
    line-height: 1.3rem;
    position: relative;
    transition: 0.5s;
    display: block;
    width: 400px;
    position: absolute;
    top: 0;
    right: 0;
    transform: translateX(200px) rotate(45deg) translate(10px,70px);
    box-shadow: 4px 4px 10px rgba(0,0,0,0.8);
    pointer-events: auto;
}
#forkongithub a {
  text-decoration: none;
  color: #fff;
}
#forkongithub>div:hover {
    background: #c11;
    color: #fff;
}
#forkongithub .contributors {
  font-size: 0.75rem;
  background: rgba(255,255,255,0.2);
  line-height: 1.2;
  padding: 0.1em;
}
#forkongithub>div::before,#forkongithub>div::after {
    content: "";
    width: 100%;
    display: block;
    position: absolute;
    top: 1px;
    left: 0;
    height: 1px;
    background: #fff;
}
#forkongithub>div::after {
    bottom: 1px;
    top: auto;
}

#forkongithub{
    z-index: 9999;
    /* needed for firefox */
    overflow: hidden;
    width: 300px;
    height: 300px;
    position: absolute;
    right: 0;
    top: 0;
    pointer-events: none;
}
#forkongithub svg{
  width: 1em;
  height: 1em;
  vertical-align: middle;
}
#forkongithub img {
  width: 1em;
  height: 1em;
  border-radius: 100%;
  vertical-align: middle;
}

@media (max-width: 900px) {
    #forkongithub>div {
        line-height: 1.2rem;
    }
}
@media (max-width: 700px) {
  #forkongithub {
    display: none;
  }
}
@media (max-width: 410px) {
    #forkongithub>div {
        font-size: 0.7rem;
        transform: translateX(150px) rotate(45deg) translate(20px,40px);
    }
}

</style>
<div id="forkongithub"><div><div><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">Fix, Fork, Contribute <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" viewBox="0 0 136 133" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
    <g transform="matrix(3.92891,0,0,3.92891,67.867,129.125)">
        <path d="M0,-31.904C-8.995,-31.904 -16.288,-24.611 -16.288,-15.614C-16.288,-8.417 -11.621,-2.312 -5.148,-0.157C-4.333,-0.008 -4.036,-0.511 -4.036,-0.943C-4.036,-1.329 -4.05,-2.354 -4.058,-3.713C-8.589,-2.729 -9.545,-5.897 -9.545,-5.897C-10.286,-7.779 -11.354,-8.28 -11.354,-8.28C-12.833,-9.29 -11.242,-9.27 -11.242,-9.27C-9.607,-9.155 -8.747,-7.591 -8.747,-7.591C-7.294,-5.102 -4.934,-5.821 -4.006,-6.238C-3.858,-7.29 -3.438,-8.008 -2.972,-8.415C-6.589,-8.826 -10.392,-10.224 -10.392,-16.466C-10.392,-18.244 -9.757,-19.698 -8.715,-20.837C-8.883,-21.249 -9.442,-22.905 -8.556,-25.148C-8.556,-25.148 -7.188,-25.586 -4.076,-23.478C-2.777,-23.84 -1.383,-24.02 0.002,-24.026C1.385,-24.02 2.779,-23.84 4.08,-23.478C7.19,-25.586 8.555,-25.148 8.555,-25.148C9.444,-22.905 8.885,-21.249 8.717,-20.837C9.761,-19.698 10.392,-18.244 10.392,-16.466C10.392,-10.208 6.583,-8.831 2.954,-8.428C3.539,-7.925 4.06,-6.931 4.06,-5.411C4.06,-3.234 4.04,-1.477 4.04,-0.943C4.04,-0.507 4.333,0 5.16,-0.159C11.628,-2.318 16.291,-8.419 16.291,-15.614C16.291,-24.611 8.997,-31.904 0,-31.904" style="fill:white;"/>
    </g>
</svg>
</a></div></div></div>

</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL2 Вытягивание вершин</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>В этой статье предполагается, что вы уже прочитали многие другие статьи,
начиная с <a href="webgl-fundamentals.html">основ</a>.
Если вы их не читали, начните с них.</p>
<p>Традиционно WebGL-приложения помещают геометрические данные в буферы.
Затем с помощью атрибутов эти данные автоматически подаются из буферов
в вершинный шейдер, где программист пишет код для преобразования их в clip space.</p>
<p>Слово <strong>традиционно</strong> здесь важно. Это всего лишь <strong>традиция</strong>
делать так. Это вовсе не требование. WebGL не
заботится о том, как мы это делаем, ему важно только, чтобы наш вершинный шейдер
присваивал координаты clip space переменной <code class="notranslate" translate="no">gl_Position</code>.</p>
<p>Давайте нарисуем куб с текстурой, используя код, похожий на примеры из <a href="webgl-3d-textures.html">статьи о текстурах</a>.
Говорят, что нам нужно как минимум 24 уникальные вершины. Это потому, что, хотя у куба всего 8 угловых
позиций, один и тот же угол используется на 3 разных гранях,
и для каждой грани нужны свои текстурные координаты.</p>
<div class="webgl_center"><img src="../resources/cube-vertices-uv.svg" style="width: 400px;"></div>
<p>На диаграмме выше видно, что для левой грани угол 3 требует
текстурных координат 1,1, а для правой грани тот же угол 3 требует
координат 0,1. Для верхней грани понадобятся ещё другие координаты.</p>
<p>Обычно это реализуется так: из 8 угловых позиций
делают 24 вершины</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">  // front
  { pos: [-1, -1,  1], uv: [0, 1], }, // 0
  { pos: [ 1, -1,  1], uv: [1, 1], }, // 1
  { pos: [-1,  1,  1], uv: [0, 0], }, // 2
  { pos: [ 1,  1,  1], uv: [1, 0], }, // 3
  // right
  { pos: [ 1, -1,  1], uv: [0, 1], }, // 4
  { pos: [ 1, -1, -1], uv: [1, 1], }, // 5
  { pos: [ 1,  1,  1], uv: [0, 0], }, // 6
  { pos: [ 1,  1, -1], uv: [1, 0], }, // 7
  // back
  { pos: [ 1, -1, -1], uv: [0, 1], }, // 8
  { pos: [-1, -1, -1], uv: [1, 1], }, // 9
  { pos: [ 1,  1, -1], uv: [0, 0], }, // 10
  { pos: [-1,  1, -1], uv: [1, 0], }, // 11
  // left
  { pos: [-1, -1, -1], uv: [0, 1], }, // 12
  { pos: [-1, -1,  1], uv: [1, 1], }, // 13
  { pos: [-1,  1, -1], uv: [0, 0], }, // 14
  { pos: [-1,  1,  1], uv: [1, 0], }, // 15
  // top
  { pos: [ 1,  1, -1], uv: [0, 1], }, // 16
  { pos: [-1,  1, -1], uv: [1, 1], }, // 17
  { pos: [ 1,  1,  1], uv: [0, 0], }, // 18
  { pos: [-1,  1,  1], uv: [1, 0], }, // 19
  // bottom
  { pos: [ 1, -1,  1], uv: [0, 1], }, // 20
  { pos: [-1, -1,  1], uv: [1, 1], }, // 21
  { pos: [ 1, -1, -1], uv: [0, 0], }, // 22
  { pos: [-1, -1, -1], uv: [1, 0], }, // 23
</code></pre>
<p>Эти позиции и текстурные координаты
кладутся в буферы и подаются в вершинный шейдер
через атрибуты.</p>
<p>Но обязательно ли делать именно так? А что если
мы хотим оставить только 8 углов
и 4 текстурные координаты? Например:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">positions = [
  -1, -1,  1,  // 0
   1, -1,  1,  // 1
  -1,  1,  1,  // 2
   1,  1,  1,  // 3
  -1, -1, -1,  // 4
   1, -1, -1,  // 5
  -1,  1, -1,  // 6
   1,  1, -1,  // 7
];
uvs = [
  0, 0,  // 0
  1, 0,  // 1
  0, 1,  // 2
  1, 1,  // 3
];
</code></pre>
<p>А для каждой из 24 вершин мы бы указывали, какие из них использовать.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">positionIndexUVIndex = [
  // front
  0, 1, // 0
  1, 3, // 1
  2, 0, // 2
  3, 2, // 3
  // right
  1, 1, // 4
  5, 3, // 5
  3, 0, // 6
  7, 2, // 7
  // back
  5, 1, // 8
  4, 3, // 9
  7, 0, // 10
  6, 2, // 11
  // left
  4, 1, // 12
  0, 3, // 13
  6, 0, // 14
  2, 2, // 15
  // top
  7, 1, // 16
  6, 3, // 17
  3, 0, // 18
  2, 2, // 19
  // bottom
  1, 1, // 20
  0, 3, // 21
  5, 0, // 22
  4, 2, // 23
];
</code></pre>
<p>Можно ли использовать это на GPU? Почему бы и нет!?</p>
<p>Мы загрузим позиции и текстурные координаты
каждую в свою текстуру, как
рассматривалось в <a href="webgl-data-textures.html">статье о data-текстурах</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">function makeDataTexture(gl, data, numComponents) {
  // расширяем данные до 4 значений на пиксель
  const numElements = data.length / numComponents;
  const expandedData = new Float32Array(numElements * 4);
  for (let i = 0; i &lt; numElements; ++i) {
    const srcOff = i * numComponents;
    const dstOff = i * 4;
    for (let j = 0; j &lt; numComponents; ++j) {
      expandedData[dstOff + j] = data[srcOff + j];
    }
  }
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(
      gl.TEXTURE_2D,
      0,            // mip уровень
      gl.RGBA32F,   // формат
      numElements,  // ширина
      1,            // высота
      0,            // граница
      gl.RGBA,      // формат
      gl.FLOAT,     // тип
      expandedData,
  );
  // фильтрация не нужна
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  return tex;
}

const positionTexture = makeDataTexture(gl, positions, 3);
const texcoordTexture = makeDataTexture(gl, uvs, 2);
</code></pre>
<p>Поскольку в текстуре может быть до 4 значений на пиксель, функция <code class="notranslate" translate="no">makeDataTexture</code>
расширяет любые данные до 4 значений на пиксель.</p>
<p>Далее создаём vertex array для хранения состояния атрибутов</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// создаём vertex array object для хранения состояния атрибутов
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
</code></pre>
<p>Теперь нужно загрузить индексы позиций и texcoord в буфер.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Создаём буфер для индексов позиций и UV
const positionIndexUVIndexBuffer = gl.createBuffer();
// Биндим его к ARRAY_BUFFER (думаем об этом как ARRAY_BUFFER = positionBuffer)
gl.bindBuffer(gl.ARRAY_BUFFER, positionIndexUVIndexBuffer);
// Кладём индексы позиций и texcoord в буфер
gl.bufferData(gl.ARRAY_BUFFER, new Uint32Array(positionIndexUVIndex), gl.STATIC_DRAW);
</code></pre>
<p>и настраиваем атрибут</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Включаем атрибут индекса позиции
gl.enableVertexAttribArray(posTexIndexLoc);

// Говорим атрибуту индекса позиции/texcoord, как забирать данные из буфера 
// positionIndexUVIndexBuffer (ARRAY_BUFFER)
{
  const size = 2;                // 2 компонента на итерацию
  const type = gl.INT;           // данные - 32-битные целые числа
  const stride = 0;              // 0 = двигаться вперёд на size * sizeof(type) каждый раз для получения следующей позиции
  const offset = 0;              // начинать с начала буфера
  gl.vertexAttribIPointer(
      posTexIndexLoc, size, type, stride, offset);
}
</code></pre>
<p>Обратите внимание, что мы вызываем <code class="notranslate" translate="no">gl.vertexAttribIPointer</code>, а не <code class="notranslate" translate="no">gl.vertexAttribPointer</code>.
<code class="notranslate" translate="no">I</code> означает integer и используется для целочисленных и беззнаковых целочисленных атрибутов.
Также заметьте, что size равен 2, поскольку на вершину приходится 1 индекс позиции и 1 индекс texcoord.</p>
<p>Хотя нам нужно только 24 вершины, мы всё равно должны рисовать 6 граней, 12 треугольников
каждая, 3 вершины на треугольник = 36 вершин. Чтобы указать, какие 6 вершин
использовать для каждой грани, мы будем использовать <a href="webgl-indexed-vertices.html">индексы вершин</a>.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const indices = [
   0,  1,  2,   2,  1,  3,  // front
   4,  5,  6,   6,  5,  7,  // right
   8,  9, 10,  10,  9, 11,  // back
  12, 13, 14,  14, 13, 15,  // left
  16, 17, 18,  18, 17, 19,  // top
  20, 21, 22,  22, 21, 23,  // bottom
];
// Создаём индексный буфер
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
// Кладём индексы в буфер
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
</code></pre>
<p>Поскольку мы хотим нарисовать изображение на самом кубе, нам нужна 3-я текстура
с этим изображением. Давайте просто создадим ещё одну 4x4 data-текстуру с шахматной доской.
Мы будем использовать <code class="notranslate" translate="no">gl.LUMINANCE</code> как формат, поскольку тогда нам нужен только один байт на пиксель.</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Создаём текстуру-шахматку
const checkerTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, checkerTexture);
// Заполняем текстуру 4x4 серой шахматкой
gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.LUMINANCE,
    4,
    4,
    0,
    gl.LUMINANCE,
    gl.UNSIGNED_BYTE,
    new Uint8Array([
      0xDD, 0x99, 0xDD, 0xAA,
      0x88, 0xCC, 0x88, 0xDD,
      0xCC, 0x88, 0xCC, 0xAA,
      0x88, 0xCC, 0x88, 0xCC,
    ]),
);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
</code></pre>
<p>Переходим к вершинному шейдеру… Мы можем получить пиксель из текстуры так:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">vec4 color = texelFetch(sampler2D tex, ivec2 pixelCoord, int mipLevel);
</code></pre>
<p>Итак, по целочисленным координатам пикселя код выше извлечёт значение пикселя.</p>
<p>Используя функцию <code class="notranslate" translate="no">texelFetch</code>, мы можем взять 1D индекс массива
и найти значение в 2D текстуре так:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">vec4 getValueByIndexFromTexture(sampler2D tex, int index) {
  int texWidth = textureSize(tex, 0).x;
  int col = index % texWidth;
  int row = index / texWidth;
  return texelFetch(tex, ivec2(col, row), 0);
}
</code></pre>
<p>Итак, учитывая эту функцию, вот наш шейдер:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-glsl">#version 300 es
in ivec2 positionAndTexcoordIndices;

uniform sampler2D positionTexture;
uniform sampler2D texcoordTexture;

uniform mat4 u_matrix;

out vec2 v_texcoord;

vec4 getValueByIndexFromTexture(sampler2D tex, int index) {
  int texWidth = textureSize(tex, 0).x;
  int col = index % texWidth;
  int row = index / texWidth;
  return texelFetch(tex, ivec2(col, row), 0);
}

void main() {
  int positionIndex = positionAndTexcoordIndices.x;
  vec3 position = getValueByIndexFromTexture(
      positionTexture, positionIndex).xyz;
 
  // Умножаем позицию на матрицу
  gl_Position = u_matrix * vec4(position, 1);

  int texcoordIndex = positionAndTexcoordIndices.y;
  vec2 texcoord = getValueByIndexFromTexture(
      texcoordTexture, texcoordIndex).xy;

  // Передаём texcoord в фрагментный шейдер
  v_texcoord = texcoord;
}
</code></pre>
<p>Внизу это по сути тот же шейдер, который мы использовали
в <a href="webgl-3d-textures.html">статье о текстурах</a>.
Мы умножаем <code class="notranslate" translate="no">position</code> на <code class="notranslate" translate="no">u_matrix</code> и выводим
texcoord в <code class="notranslate" translate="no">v_texcoord</code> для передачи в фрагментный шейдер.</p>
<p>Разница только в том, как мы получаем position и
texcoord. Мы используем переданные индексы и получаем
эти значения из соответствующих текстур.</p>
<p>Чтобы использовать шейдер, нужно найти все локации:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// настраиваем GLSL программу
const program = webglUtils.createProgramFromSources(gl, [vs, fs]);

// ищем, куда должны идти вершинные данные
const posTexIndexLoc = gl.getAttribLocation(
    program, &quot;positionAndTexcoordIndices&quot;);

// ищем uniform'ы
const matrixLoc = gl.getUniformLocation(program, &quot;u_matrix&quot;);
const positionTexLoc = gl.getUniformLocation(program, &quot;positionTexture&quot;);
const texcoordTexLoc = gl.getUniformLocation(program, &quot;texcoordTexture&quot;);
const u_textureLoc = gl.getUniformLocation(program, &quot;u_texture&quot;);
</code></pre>
<p>Во время рендеринга настраиваем атрибуты:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Говорим использовать нашу программу (пару шейдеров)
gl.useProgram(program);

// Устанавливаем буфер и состояние атрибутов
gl.bindVertexArray(vao);
</code></pre>
<p>Затем нужно привязать все 3 текстуры и настроить все
uniform’ы:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Устанавливаем матрицу
gl.uniformMatrix4fv(matrixLoc, false, matrix);

// кладём текстуру позиций на texture unit 0
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, positionTexture);
// Говорим шейдеру использовать texture unit 0 для positionTexture
gl.uniform1i(positionTexLoc, 0);

// кладём текстуру texcoord на texture unit 1
gl.activeTexture(gl.TEXTURE0 + 1);
gl.bindTexture(gl.TEXTURE_2D, texcoordTexture);
// Говорим шейдеру использовать texture unit 1 для texcoordTexture
gl.uniform1i(texcoordTexLoc, 1);

// кладём текстуру-шахматку на texture unit 2
gl.activeTexture(gl.TEXTURE0 + 2);
gl.bindTexture(gl.TEXTURE_2D, checkerTexture);
// Говорим шейдеру использовать texture unit 2 для u_texture
gl.uniform1i(u_textureLoc, 2);
</code></pre>
<p>И наконец рисуем:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">// Рисуем геометрию
gl.drawElements(gl.TRIANGLES, 6 * 6, gl.UNSIGNED_SHORT, 0);
</code></pre>
<p>И получаем куб с текстурой, используя только 8 позиций и
4 текстурные координаты:</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-pulling-vertices.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-pulling-vertices.html" target="_blank">Нажмите, чтобы открыть в новом окне</a>
</div>

</p>
<p>Несколько вещей для заметки. Код ленивый и использует 1D
текстуры для позиций и текстурных координат.
Текстуры могут быть только такой ширины. <a href="https://web3dsurvey.com/webgl/parameters/MAX_TEXTURE_SIZE">Насколько широкими - зависит от машины</a>, что можно запросить с помощью:</p>
<pre class="prettyprint notranslate" translate="no"><code class="lang-js">const maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
</code></pre>
<p>Если бы мы хотели обработать больше данных, чем это, нам нужно было бы
выбрать какой-то размер текстуры, который подходит нашим данным, и распределить
данные по нескольким строкам, возможно
дополняя последнюю строку, чтобы получился прямоугольник.</p>
<p>Ещё одна вещь, которую мы делаем здесь - используем 2 текстуры,
одну для позиций, одну для текстурных координат.
Нет причин, по которым мы не могли бы положить оба данных в
ту же текстуру либо чередуя:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">pos,uv,pos,uv,pos,uv...
</code></pre>
<p>либо в разных местах в текстуре:</p>
<pre class="prettyprint notranslate" translate="no"><code class="notranslate" translate="no">pos,pos,pos,...
uv, uv, uv,...
</code></pre>
<p>Нам просто пришлось бы изменить математику в вершинном шейдере,
которая вычисляет, как их извлекать из текстуры.</p>
<p>Возникает вопрос: стоит ли делать такие вещи?
Ответ: “зависит от обстоятельств”. В зависимости от GPU это
может быть медленнее, чем более традиционный способ.</p>
<p>Цель этой статьи была в том, чтобы ещё раз указать,
что WebGL не заботится о том, как вы устанавливаете <code class="notranslate" translate="no">gl_Position</code> с
координатами clip space, и не заботится о том, как вы
выводите цвет. Ему важно только, чтобы вы их установили.
Текстуры - это действительно просто 2D массивы данных с произвольным доступом.</p>
<p>Когда у вас есть проблема, которую вы хотите решить в WebGL,
помните, что WebGL просто запускает шейдеры, и эти шейдеры
имеют доступ к данным через uniform’ы (глобальные переменные),
атрибуты (данные, которые приходят за итерацию вершинного шейдера),
и текстуры (2D массивы с произвольным доступом). Не позволяйте
традиционным способам использования WebGL помешать вам
увидеть настоящую гибкость, которая там есть.</p>
<div class="webgl_bottombar">
<h3>Почему это называется Vertex Pulling?</h3>
<p>Я на самом деле слышал этот термин только недавно (июль 2019),
хотя использовал технику раньше. Он происходит из
<a href='https://www.google.com/search?q=OpenGL+Insights+"Programmable+Vertex+Pulling"+article+by+Daniel+Rakos'>статьи OpenGL Insights "Programmable Vertex Pulling" от Daniel Rakos</a>.
</p>
<p>Это называется vertex *pulling* (вытягивание вершин), поскольку это вершинный шейдер
решает, какие вершинные данные читать, в отличие от традиционного способа, где
вершинные данные поставляются автоматически через атрибуты. По сути
вершинный шейдер *вытягивает* данные из памяти.</p>
</div> 
    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-pulling-vertices.html" >English</a>
    <option value="/webgl/lessons/de/webgl-pulling-vertices.html" >Deutsch</a>
    <option value="/webgl/lessons/ja/webgl-pulling-vertices.html" >日本語</a>
    <option value="/webgl/lessons/ko/webgl-pulling-vertices.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-pulling-vertices.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/ru/webgl-pulling-vertices.html" selected>Русский</a>
    <option value="/webgl/lessons/zh_cn/webgl-pulling-vertices.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Основы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-getting-webgl2.html">Как использовать WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl-fundamentals.html">Основы</a></li>
<li><a href="/webgl/lessons/ru/webgl-how-it-works.html">Как это работает</a></li>
<li><a href="/webgl/lessons/ru/webgl-shaders-and-glsl.html">Шейдеры и GLSL</a></li>
<li><a href="/webgl/lessons/resources/webgl-state-diagram.html">WebGL2 Диаграмма состояния</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl2-whats-new.html">Что нового в WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2.html">Переход с WebGL1 на WebGL2</a></li>
<li><a href="/webgl/lessons/ru/webgl1-to-webgl2-fundamentals.html">Отличия от WebGLFundamentals.org до WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Обработка изображений</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-image-processing.html">Обработка изображений</a></li>
<li><a href="/webgl/lessons/ru/webgl-image-processing-continued.html">Продвинутая обработка изображений</a></li>
        </ul>
  <li>2D трансформации, повороты, масштабирование и матричные операции</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-translation.html">2D Трансляция</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-rotation.html">2D Вращение</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-scale.html">2D Масштабирование</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrices.html">2D Матрицы</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-orthographic.html">Ортографическая 3D</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective.html">3D Перспектива</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-camera.html">3D - Камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-naming.html">3D - Именование матриц</a></li>
        </ul>
  <li>Освещение</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-lighting-directional.html">Направленное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-point.html">Точечное освещение</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-lighting-spot.html">Прожекторное освещение</a></li>
        </ul>
  <li>Организация и рефакторинг</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-less-code-more-fun.html">Меньше кода, больше удовольствия</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-multiple-things.html">Рисование множественных объектов</a></li>
<li><a href="/webgl/lessons/ru/webgl-scene-graph.html">Графы сцен</a></li>
        </ul>
  <li>Геометрия</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-geometry-lathe.html">3D Геометрия - Токарная обработка</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj.html">Загрузка .obj файлов</a></li>
<li><a href="/webgl/lessons/ru/webgl-load-obj-w-mtl.html">Загрузка .obj с .mtl файлами</a></li>
        </ul>
  <li>Текстуры</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-3d-textures.html">Текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/ru/webgl-2-textures.html">Использование 2 или более текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/ru/webgl-3d-perspective-correct-texturemapping.html">Перспективно-корректное наложение текстур</a></li>
<li><a href="/webgl/lessons/ru/webgl-planar-projection-mapping.html">Планарное и перспективное проекционное отображение</a></li>
        </ul>
  <li>Рендеринг в текстуру</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-render-to-texture.html">Рендеринг в текстуру</a></li>
        </ul>
  <li>Тени</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-shadows.html">Тени</a></li>
        </ul>
  <li>Техники</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-matrix-stack.html">2D - Стек Матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-sprites.html">Спрайты</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-cube-maps.html">Кубические карты</a></li>
<li><a href="/webgl/lessons/ru/webgl-environment-maps.html">Карты окружения</a></li>
<li><a href="/webgl/lessons/ru/webgl-skybox.html">Скайбоксы</a></li>
<li><a href="/webgl/lessons/ru/webgl-skinning.html">Скининг</a></li>
<li><a href="/webgl/lessons/ru/webgl-fog.html">Fog</a></li>
<li><a href="/webgl/lessons/ru/webgl-picking.html">Выбор объектов (клик по объектам)</a></li>
        </ul>
  <li>Текст</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-text-html.html">Текст - HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-canvas2d.html">Текст - Canvas 2D</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-texture.html">Текст - Использование текстуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-text-glyphs.html">Текст - Использование текстуры глифов</a></li>
        </ul>
  <li>GPGPU</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-gpgpu.html">GPGPU</a></li>
        </ul>
        </ul>
  <li>Советы</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-smallest-programs.html">Самые маленькие программы</a></li>
<li><a href="/webgl/lessons/ru/webgl-drawing-without-data.html">Рисование без данных</a></li>
<li><a href="/webgl/lessons/ru/webgl-shadertoy.html">Shadertoy</a></li>
<li><a href="/webgl/lessons/ru/webgl-pulling-vertices.html">Вытягивание вершин</a></li>
        </ul>
  <li>Оптимизация</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-indexed-vertices.html">Индексированные вершины (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/ru/webgl-instanced-drawing.html">Инстансинг (Instanced Drawing)</a></li>
        </ul>
  <li>Разное</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-setup-and-installation.html">Настройка и установка</a></li>
<li><a href="/webgl/lessons/ru/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/ru/webgl-resizing-the-canvas.html">Изменение размера Canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-animation.html">Анимация</a></li>
<li><a href="/webgl/lessons/ru/webgl-points-lines-triangles.html">Точки, линии и треугольники</a></li>
<li><a href="/webgl/lessons/ru/webgl-multiple-views.html">Множественные виды, множественные canvas</a></li>
<li><a href="/webgl/lessons/ru/webgl-visualizing-the-camera.html">Визуализация камеры</a></li>
<li><a href="/webgl/lessons/ru/webgl-and-alpha.html">WebGL2 и альфа-канал</a></li>
<li><a href="/webgl/lessons/ru/webgl-2d-vs-3d-library.html">2D против 3D библиотек</a></li>
<li><a href="/webgl/lessons/ru/webgl-anti-patterns.html">Анти-паттерны</a></li>
<li><a href="/webgl/lessons/ru/webgl-matrix-vs-math.html">WebGL2 Матрицы против математических матриц</a></li>
<li><a href="/webgl/lessons/ru/webgl-precision-issues.html">Проблемы точности</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#screenshot">Скриншот канваса</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#preservedrawingbuffer">Как не очищать канвас</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#tabindex">Получение ввода с клавиатуры</a></li>
<li><a href="/webgl/lessons/ru/webgl-tips.html#html-background">Использование WebGL2 как фона в HTML</a></li>
<li><a href="/webgl/lessons/ru/webgl-cross-platform-issues.html">Cross Platform Issues</a></li>
<li><a href="/webgl/lessons/ru/webgl-qna.html">Questions and Answers</a></li>
        </ul>
  <li>Справочник</li>
        <ul>
          <li><a href="/webgl/lessons/ru/webgl-attributes.html">Атрибуты</a></li>
<li><a href="/webgl/lessons/ru/webgl-texture-units.html">Текстурные юниты</a></li>
<li><a href="/webgl/lessons/ru/webgl-framebuffers.html">Framebuffers</a></li>
<li><a href="/webgl/lessons/ru/webgl-readpixels.html">readPixels</a></li>
<li><a href="/webgl/lessons/ru/webgl-references.html">Ссылки</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API документация</a></li>
  <li><a href="https://twgljs.org">TWGL, легковесная библиотека-помощник для WebGL</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        
<div>Есть предложения или замечания? <a href="https://github.com/gfxfundamentals/webgl2-fundamentals/issues">Создайте issue на GitHub</a>.</div>
  

        <div id="disqus_thread"></div>
        <script>
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL2 Вытягивание вершин';
            var disqus_title = 'WebGL2 Вытягивание вершин';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script>
const settings = {
  contribTemplate: "Спасибо <a href=\"${html_url}\"><img src=\"${avatar_url}\"> ${login}</a><br>за <a href=\"https://github.com/${owner}/${repo}/commits?author=${login}\">${contributions} вкладов</a>",
  owner: "gfxfundamentals",
  repo: "webgl2-fundamentals",
};
</script>
<script src="/contributors.js"></script>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js" type="module"></script>
<script>
</script>


</html>



